<!--This Document is generated by GameMaker, if you edit it by hand then you do so at your own risk!-->
<object>
  <spriteName>&lt;undefined&gt;</spriteName>
  <solid>0</solid>
  <visible>0</visible>
  <depth>0</depth>
  <persistent>0</persistent>
  <parentName>objActor</parentName>
  <maskName>&lt;undefined&gt;</maskName>
  <events>
    <event eventtype="0" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Set actor properties
event_inherited();
hp = 8;
sprite = cSprMario;
frameSpd = 0.01;
fSolid = true;
fPushable = true;
onGround = true;
//Player animation
for (var i = 0; i &lt; 2; i++) headDir[i] = 0;
customFrameIndex = 0;
//Player movement &amp; gimmick variables
spd = 0;
fric = 0.2;
moveDir = 0;
jumpSpd = 2.5;
targetDir = faceDir;
holding = noone;
//Variables with the postfix "Snd" have arrays that can be extended. Use this to assign
//multiple sounds to one variable.
jumpSnd[0] = noone;
fallSnd[0] = noone;
hurtSnd[0] = noone;
deadSnd[0] = noone;
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="7" enumb="24">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Update audio &amp; position
actor_update();
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="7" enumb="23">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Move test
if (!instance_exists(objTransition) &amp;&amp; (z &lt; global.minZ - 300 || timer_tick(2))) transition_create(global.currentRoom, c_black);
if (instance_exists(objCamera))
    if (timer_tick(1)) fVisible = objCamera.mode != 1;
    else if (timer[1] &amp;&amp; objCamera.mode != 1) fVisible = !fVisible;
if (onGround)
{
    //Death cutscene
    if (!hp &amp;&amp; !cutscene_exists())
    {
        timer[1] = -65536;
        timer[2] = 60;
        player_die(0, deadSnd);
        with (instance_create(objCamera.x, objCamera.y, objCutscene))
        {
            direction = global.cD;
            pitch = global.cP;
            z = global.cZ;
            cutscene_create();
            var xx = other.x + lengthdir_x(32, other.faceDir), yy = other.y + lengthdir_y(32, other.faceDir);
            cutscene_camera(xx, yy, other.z, point_direction(xx, yy, other.x, other.y), 0, 30, 0);
        }
    }
}
onGround = fOnGround || c_raycast_world(x, y, z, x, y, bottom - 2, 1);
if (!hp || cutscene_exists()) exit
if (keyboard_check_pressed(ord("R")))
{
    sliding = false;
    fOnGround = false;
    hSpeed = 0;
    vSpeed = 0;
    zSpeed = 0;
    x = xstart;
    y = ystart;
    z = 300;
}
var keyX = global.bind[0, 5] - global.bind[2, 6], keyY = global.bind[3, 5] - global.bind[1, 6], keyVec = point_distance(0, 0, keyX, keyY);
spd = point_distance(0, 0, hSpeed, vSpeed);
if (keyVec &gt; 0.1 &amp;&amp; !sliding)
{
    var gotoDir = point_direction(0, 0, keyX, keyY);
    if (onGround)
    {
        if (abs(angle_difference(targetDir, gotoDir)) &gt;= 170)
        {
            if (abs(spd) &gt;= 0.06)
            {
                spd *= 0.89;
                anim = cAniMarioSkid;
                frame = 0;
                particle_create(x, y, bottom, cParTypeSkid);
                d3d_sound_play(cSndSkid, false, 1);
                faceRoll = lerp_angle(faceRoll, 0, 0.075);
            }
            else
            {
                if (anim = cAniMarioSkid) anim = cAniMarioSkid2;
                targetDir = gotoDir;
                moveDir = gotoDir;
            }
        }
        else
        {
            var moveDirInc = turn_to_angle(global.cD + targetDir, 10, moveDir);
            spd = min(spd + 0.1, lengthdir_x(2.5, floorPitch) - 0.5 * (keyVec &gt;= 0.25 &amp;&amp; keyVec &lt;= 0.75));
            targetDir = gotoDir;
            moveDir += moveDirInc;
            faceRoll = lerp_angle(faceRoll, 1.5 * -moveDirInc, 0.1);
        }
    }
    else
    {
        var tiltDir = global.cD + gotoDir, tiltVec = keyVec * 0.06;
        hSpeed = clamp(hSpeed + lengthdir_x(tiltVec, tiltDir), -2.5, 2.5);
        vSpeed = clamp(vSpeed + lengthdir_y(tiltVec, tiltDir), -2.5, 2.5);
        targetDir = faceDir;
        moveDir = tiltDir;
    }
}
else if (onGround) if (abs(spd) &gt;= 0.01)
{
    spd *= 0.9;
    faceRoll = lerp_angle(faceRoll, 0, 0.1);
}
else
{
    spd = 0;
    faceRoll = 0;
}
else
{
    hSpeed *= 0.99;
    vSpeed *= 0.99;
    spd = point_distance(0, 0, hSpeed, vSpeed);
}
if (onGround)
{
    faceDir += turn_to_angle(moveDir, 10, faceDir);
    hSpeed = lengthdir_x(spd, moveDir);
    vSpeed = lengthdir_y(spd, moveDir);
}
//jump when on the ground
if (onGround &amp;&amp; !sliding &amp;&amp; floorPitch &lt; 60 &amp;&amp; global.bind[4, 3])
{
    player_sound_play(jumpSnd);
    d3d_sound_play(cSndJump, false, 1);
    if !(c_raycast_world(x, y, z, x, y, top + jumpSpd, 1)) z += jumpSpd;
    zSpeed = jumpSpd - 0.1;
    anim = cAniMarioJump + (angle_difference(faceDir, global.cD) &lt; 0);
    frame = 0;
}
//Get nearest enemy
var near = instance_nearest(x, y, objEnemy);
//If nearest enemy is within the range of the player, crank up that battle music.
if (near) global.battle = point_distance_3d(x, y, z, near.x, near.y, near.z) &lt; 100;
else global.battle = false;
//Holding mechanic
if (global.bind[6, 3])
    if (holding) player_drop_holdable(hSpeed + lengthdir_x(1.5, faceDir), vSpeed + lengthdir_y(1.5, faceDir), zSpeed + 1.5);
    else
    {
        near = instance_nearest(x, y, objHoldable);
        if (near &amp;&amp; point_distance_3d(x, y, z, near.x, near.y, near.z) &lt; 3 * near.radius)
        {
            near.target = self;
            holding = near;
        }
        else
        {
            //If there's nothing to be held, then the player might be talking to an NPC
            near = instance_nearest(x, y, objNPC);
            if (near &amp;&amp; fOnGround)
            {
                var distance = point_distance_3d(near.x, near.y, near.z, x, y, z), dir = point_direction(near.x, near.y, x, y);
                if (distance &lt; near.radius + 16 &amp;&amp; abs(angle_difference(dir, near.faceDir)) &lt; 60)
                {
                    faceDir = point_direction(x, y, near.x, near.y);
                    var distanceDir = faceDir - 90, distanceHalf = distance * 0.5, xx = near.x + lengthdir_x(distanceHalf, dir) + lengthdir_x(32, distanceDir), yy = near.y + lengthdir_y(distanceHalf, dir) + lengthdir_y(32, distanceDir);
                    near.working = true;
                    with (instance_create(objCamera.x, objCamera.y, objCutscene))
                    {
                        z = objCamera.z;
                        direction = objCamera.faceDir;
                        pitch = objCamera.pitch;
                        cutscene_create();
                        cutscene_camera(xx, yy, near.z - 4, point_direction(xx, yy, near.x, near.y), 0, 60, 0)
                        cutscene_wait(20);
                        //Add messages manually, because cutscene_message only allows string inputs.
                        ds_list_add(list, 3);
                        var strings = ds_list_create(), i = 0;
                        repeat (array_length_1d(near.message))
                        {
                           ds_list_add(strings, near.message[i]);
                           i++; 
                        }
                        ds_list_add(list, strings);
                        cutscene_wait_message();
                        cutscene_wait(10);
                        cutscene_end();
                    }
                }
            }
        }
    }
//Check if the player is overlapping a cutscene trigger area
near = collision_point(x, y, objCutsceneTrigger, false, true);
if (near) //If there is a trigger, create the cutscene
    with (near)
    {
        with (instance_create(global.cX, global.cY, objCutscene))
        {
            z = global.cZ;
            direction = global.cD;
            pitch = global.cP;
            cutscene_create();
            ds_list_copy(list, other.list); //Write all cutscene data from trigger to cutscene
        }
        instance_destroy(); //Remove the trigger
    }
//Hurt test
if (keyboard_check_pressed(ord("Z"))) event_user(0);
//Bottomless pit detection
if (z &lt; global.minZ)
{
    player_die(1, fallSnd);
    with (instance_create(0, 0, objCutscene))
    {
        global.follow = true;
        cutscene_create();
    }
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="7" enumb="10">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Hurt player
if (!timer[1] &amp;&amp; hp)
{
    objCamera.flinch = irandom_range(-20, 20);
    player_sound_play(hurtSnd);
    hp -= 2;
    timer[1] = 120;
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
  </events>
  <PhysicsObject>0</PhysicsObject>
  <PhysicsObjectSensor>0</PhysicsObjectSensor>
  <PhysicsObjectShape>0</PhysicsObjectShape>
  <PhysicsObjectDensity>0.5</PhysicsObjectDensity>
  <PhysicsObjectRestitution>0.100000001490116</PhysicsObjectRestitution>
  <PhysicsObjectGroup>0</PhysicsObjectGroup>
  <PhysicsObjectLinearDamping>0.100000001490116</PhysicsObjectLinearDamping>
  <PhysicsObjectAngularDamping>0.100000001490116</PhysicsObjectAngularDamping>
  <PhysicsObjectFriction>0.200000002980232</PhysicsObjectFriction>
  <PhysicsObjectAwake>-1</PhysicsObjectAwake>
  <PhysicsObjectKinematic>0</PhysicsObjectKinematic>
  <PhysicsShapePoints/>
</object>
