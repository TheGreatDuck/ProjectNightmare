<!--This Document is generated by GameMaker, if you edit it by hand then you do so at your own risk!-->
<object>
  <spriteName>&lt;undefined&gt;</spriteName>
  <solid>0</solid>
  <visible>-1</visible>
  <depth>0</depth>
  <persistent>0</persistent>
  <parentName>objActor</parentName>
  <maskName>&lt;undefined&gt;</maskName>
  <events>
    <event eventtype="0" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Set up camera
event_inherited();
d3d_start();
target = objPlayer; //Target must be objActor child
range = 80;
radius = 1;
height = 2;
fGravity = false;
fVisible = false;
fGhost = true;
fShadow = false;
//Set first person zooming
mode = 0; //0 - normal, 1 - first person, 2 - free scroll
bob = 0;
flinch = 0;
sensX = 10;
sensY = 10;
previousZ = 0;
//Set global variables
global.cX = 0;
global.cY = 0;
global.cZ = 0;
global.cD = 0;
global.cP = 0;
audio_emitter_free(emitter);
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="1" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>//Turn off D3D
d3d_end();
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="7" enumb="25">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>//
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="7" enumb="23">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Attach camera to target
var cursor = cr_none;
if (window_has_focus()) cursor = cr_default;
window_set_cursor(cursor);
if (target &amp;&amp; instance_exists(target))
{
    if !(cutscene_exists()) mouse_look(false);
    if (!cutscene_exists() || (cutscene_exists() &amp;&amp; global.follow))
    {
        var tZ = previousZ;
        if (target.z &lt; previousZ - 10|| target.z &gt; previousZ + 40) tZ = target.z;
        if (target.fOnGround &amp;&amp; target.shadowZ != -65536) previousZ = target.shadowZ + target.half;
        var rangeTo = 80, zTo = max(tZ, target.shadowZ) + 16, camZTo = zTo - 2;
        if (c_raycast_world(target.x, target.y, zTo, target.x - lengthdir_x(80, faceDir), target.y - lengthdir_y(80, faceDir), zTo, 1))
        {
            rangeTo = point_distance_3d(target.x, target.y, target.z, c_hit_x(), c_hit_y(), c_hit_z());
            camZTo = zTo + (target.z - tZ) / (point_distance(x, y, target.x, target.y) / 16) - 10;
        }
        range = lerp(range, rangeTo, 0.2);
        x = target.x - lengthdir_x(range, faceDir);
        y = target.y - lengthdir_y(range, faceDir);
        z = lerp(z, max(zTo, global.minZ), 0.2);
        facePitch = lerp_angle(facePitch, point_pitch(x, y, z, target.x, target.y, camZTo), 0.2);
        global.cX = x;
        global.cY = y;
        global.cZ = z;
        global.cD = faceDir;
        global.cP = facePitch;
    }
    /*if (cutscene_exists())
    {
        mode = 0;
        target.fVisible = true;
    }
    if (!cutscene_exists() || (cutscene_exists() &amp;&amp; global.follow))
    {
        //Ready up target coordinates
        var tX = target.x, tY = target.y, tRZ = target.bottom, tZ = tRZ, tZS = target.zSpeed, tSZ = target.shadowZ, tD = target.faceDir;
        tZ = previousZ;
        if (target.fOnGround &amp;&amp; tSZ != -65536) previousZ = tSZ;
        if (tRZ &lt; previousZ - 10|| tRZ &gt; previousZ + 40) tZ = tRZ;
        if (target.hp &amp;&amp; !cutscene_exists())
        {
            //Toggle freelook
            if (global.bind[8, 3])
            {
                if (mode == 2)
                {
                    mode = 0;
                    audio_play_sound(global.snd[| cSndCameraOut], 1, false);
                }
                else
                {
                    mode = 2;
                    audio_play_sound(global.snd[| cSndCameraIn], 1, false);
                }
                target.fVisible = true;
            }
            //Toggle aiming
            if (global.bind[9, 3])
            {
                if (mode == 1)
                {
                    mode = 0;
                    target.fVisible = true;
                    target.faceDir = faceDir;
                    audio_play_sound(global.snd[| cSndCameraOut], 1, false);
                }
                else
                {
                    mode = 1;
                    target.fVisible = false;
                    faceDir = tD;
                    audio_play_sound(global.snd[| cSndCameraIn], 1, false);
                }
                pitch = 0;
            }
        }
        else mode = 0;
        //Camera mechanics
        flinch = lerp(flinch, 0, 0.05);
        if (mode == 1)
        {
            global.cX = tX;
            global.cY = tY;
            var b = 0;
            if (target.fOnGround &amp;&amp; target.fric == 0.2) b = lengthdir_y(target.spdDis * 3, current_time * 0.85);
            if (target.sliding || target.fric != 0.2) b = -6;
            bob = lerp(bob, b, 0.05);
            global.cZ = target.top - 4 + bob;
            //Mouselook
            mouse_look();
            target.faceDir = global.cD;
        }
        else
        {
            var lerpAmount = 0.18;
            //Freelook
            if (mode == 2)
            {
                mouse_look();
                lerpAmount = 0.5;
            }
            else if (global.bind[7, 3] &amp;&amp; faceDir != tD)
            {
                faceDir = tD;
                audio_play_sound(global.snd[| cSndCamera], 1, false);
            }
            //Set the increments of the camera to zoom out for 3rd person
            var incX = lengthdir_x(range, faceDir), incY = lengthdir_y(range, faceDir), incZ = 0, obstructed = false, tBlockZ = tRZ + 24, tBlockZ2 = tZ + 24, tToX = tX - incX, tToY = tY - incY, tToZ = tBlockZ2, maxPitch = 89.5, minPitch = -89.5;
            if (mode == 2)
            {
                incX = lengthdir_x(lengthdir_x(range, faceDir), pitch);
                incY = lengthdir_x(lengthdir_y(range, faceDir), pitch);
                incZ = lengthdir_y(range, pitch);
                tToX = tX - incX;
                tToY = tY - incY;
                tToZ = tBlockZ2 + incZ;
            }
            //If there is a block behind...
            if (c_raycast_world(tX, tY, tBlockZ, tX - incX, tY - incY, tBlockZ + incZ, 1))
            {
                tToX = c_hit_x();
                tToY = c_hit_y();
                tToZ = c_hit_z();
                obstructed = true;
            }
            if (obstructed)
            {
                tBlockZ2 = tZ + 10;
                if (mode == 2) tToZ = tBlockZ2 + incZ;
            }
            //smooth turning
            global.cX = lerp(global.cX, tToX, lerpAmount);
            global.cY = lerp(global.cY, tToY, lerpAmount);
            global.cZ = max(global.minZ, lerp(global.cZ, tToZ, 0.1));
            x = global.cX;
            y = global.cY;
            z = global.cZ;
            if !(mode == 2) pitch += turn_to_angle(point_pitch(global.cX, global.cY, global.cZ, tX, tY, tBlockZ2 - 10), 2, pitch);
            else
            {
                minPitch = -45;
                maxPitch = 0;
            }
            pitch = clamp(pitch, minPitch, maxPitch);
        }
    }*/
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="8" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Rendering
draw_set_color(c_white);
var realPitch = facePitch;
if (mode == 1) realPitch = clamp(facePitch + flinch, -89.5, 89.5); //Add flinching if first person mode
var cCos = dcos(global.cD), cSin = dsin(global.cD), cTan = dtan(realPitch);
d3d_set_projection_ext(global.cX, global.cY, global.cZ, global.cX + cCos, global.cY - cSin, global.cZ + cTan, 0, 0, 1, 45, view_wview[0] / view_hview[0], 1, global.maxRender);
audio_listener_position(global.cX, global.cY, global.cZ);
audio_listener_orientation(cCos, -cSin, cTan, 0, 0, 1);
//Draw the skybox
if (global.skybox != noone)
{
    d3d_set_zwriteenable(false);
    d3d_draw_ellipsoid(global.cX + 128, global.cY + 128, global.cZ + 256, global.cX - 128, global.cY - 128, global.cZ - 256, texture_get(global.skybox), 1, -1, 32);
    d3d_set_zwriteenable(true);
}
//Draw world model
texture_set_repeat(true);
shader_set(sh_smf_animate);
shader_set_uniform_f(shader_get_uniform(sh_smf_animate, "fogStart"), global.fog[0]);
shader_set_uniform_f(shader_get_uniform(sh_smf_animate, "fogEnd"), global.fog[1]);
shader_set_uniform_f(shader_get_uniform(sh_smf_animate, "fogColor"), global.fog[2], global.fog[3], global.fog[4], 1);
shader_set_uniform_f(shader_get_uniform(sh_smf_animate, "lightDirection"), global.light[0], global.light[1], global.light[2]);
shader_set_uniform_f(shader_get_uniform(sh_smf_animate, "lightColor"), global.light[3], global.light[4], global.light[5], 1);
shader_set_uniform_f(shader_get_uniform(sh_smf_animate, "lightAmbient"), global.light[6], global.light[7], global.light[8], 1);
var i = 0, roomData = ds_map_find_value(global.worldData[0], global.levelRoom), roomTextures = roomData[| 1], roomModels = roomData[| 2];
repeat (ds_list_size(roomModels))
{
    smf_model_draw(roomModels[| i], texture_get(roomTextures[| i]));
    i++;
}
texture_set_repeat(false);
//Draw actors with sprites
with (objActor)
{
    if (fVisible &amp;&amp; sprite != -1)
    {
        var getSprite = sprite_get(sprite), getType = sprite_type(sprite);
        switch (getType)
        {
            case (0):
            case (1):
            case (2):
                var cFrame = frame, size = scale * 0.5;
                if (getType)
                {
                    var spritePitch = -90;
                    if (getType == 2) spritePitch = global.cP - 90;
                    matrix_set(matrix_world, matrix_build(x, y, bottom, spritePitch, global.cD - 90, 0, size * image_get_width(getSprite), size * image_get_height(getSprite), 1));
                    if (getType == 1)
                    {
                        var dir = (round((point_direction(x, y, global.cX, global.cY) - faceDir) / 90)) mod (4), frames = image_get_number(getSprite);
                        while (dir &lt; 0) dir += 4;
                        cFrame = min(((frames * 0.25) * dir) + frame, frames - 1);
                    }
                }
                smf_model_draw(global.worldData[1], ds_list_find_value(global.spr[| sprite], 2 + cFrame));
            break
            case (3):
            case (4):
                var posMatrix = matrix_build(x, y, bottom, faceRoll, facePitch, faceDir, scale, scale, scale), submodels = getSprite[| 0], bodygroups = getSprite[| 1], frameSample = undefined;
                matrix_set(matrix_world, posMatrix);
                if (getType == 4)
                {
                    var animation = getSprite[| 2 + anim];
                    if !(is_undefined(customFrame)) frameSample = smf_sample_create_from_frame(customFrame);
                    else frameSample = smf_sample_blend(animation[| 2 + frame], animation[| 2 + (frame + 1) mod (ds_list_size(animation) - 2)], frac(frame));
                    smf_animation_set_shader_uniforms(sh_smf_animate, frameSample);
                }
                //Submodels
                i = 0;
                repeat (ds_list_size(submodels))
                {
                    if (skin[i] == -1) continue //Don't draw disabled submodels
                    var submodel = submodels[| i];
                    smf_model_draw(submodel[| 0], global.mtl[| submodel[| 1 + skin[i]]]);
                    i++;
                }
                //Bodygroups
                i = 0;
                repeat (ds_list_size(bodygroups))
                {
                    if (bodygroup[i] == -1) continue //Don't draw disabled bodygroups
                    var bgModel = bodygroups[| i];
                    smf_model_draw(bgModel[| 1 + bodygroup[i]], global.mtl[| bgModel[| 0]]);
                    i++;
                }
                if (object_index == objMario &amp;&amp; holding != noone &amp;&amp; holding.holdableType) with (holding)
                {
                    getType = sprite_type(sprite);
                    if (getType &gt; 2)
                    {
                        var getSprite = sprite_get(sprite), submodels = getSprite[| 0], bodygroups = getSprite[| 1], holdFrameSample = undefined, size = scale / other.scale;
                        matrix_set(matrix_world, matrix_multiply(matrix_multiply(matrix_build(0, 0, 0, 0, -180, -180, size, size, size), smf_matrix_create_from_dualquat(smf_sample_get_bone_orientation(frameSample, 15))), posMatrix));
                        if (getType == 4)
                        {
                            var animation = getSprite[| 2 + anim];
                            if !(is_undefined(customFrame)) holdFrameSample = smf_sample_create_from_frame(customFrame);
                            else holdFrameSample = smf_sample_blend(animation[| 2 + frame], animation[| 2 + (frame + 1) mod (ds_list_size(animation) - 2)], frac(frame));
                            smf_animation_set_shader_uniforms(sh_smf_animate, holdFrameSample);
                        }
                        //Submodels
                        i = 0;
                        repeat (ds_list_size(submodels))
                        {
                            if (skin[i] == -1) continue //Don't draw disabled submodels
                            var submodel = submodels[| i];
                            smf_model_draw(submodel[| 0], global.mtl[| submodel[| 1 + skin[i]]]);
                            i++;
                        }
                        //Bodygroups
                        i = 0;
                        repeat (ds_list_size(bodygroups))
                        {
                            if (bodygroup[i] == -1) continue //Don't draw disabled bodygroups
                            var bgModel = bodygroups[| i];
                            smf_model_draw(bgModel[| 1 + bodygroup[i]], global.mtl[| bgModel[| 0]]);
                            i++;
                        }
                    }
                }
            break
        }
    }
    if (fShadow &amp;&amp; shadowZ != -65536 &amp;&amp; global.cZ &gt; shadowZ)
    {
        matrix_set(matrix_world, matrix_build(x, y, shadowZ, 0, floorPitch, floorAngle, 1, 1, 1));
        var shadowSize = 2 * radius;
        draw_image_stretched_ext(global.bg[| cBgShadow], 0, -radius, -radius, shadowSize, shadowSize, c_white, 0.5);
    }
}
shader_reset();
i = 0;
repeat (ds_list_size(global.particles))
{
    var particle = global.particles[| i];
    matrix_set(matrix_world, matrix_build(particle[| cParX], particle[| cParY], particle[| cParZ], -90, global.cD - 90, global.cP, 1, 1, 1));
    var size = particle[| cParScale] * 0.5;
    draw_image_ext(sprite_get(particle[| cParSprite]), particle[| cParFrame], 0, 0, size, -size, 0, c_white, 1);
    i++;
}
smf_matrix_reset();
</string>
          </argument>
        </arguments>
      </action>
    </event>
  </events>
  <PhysicsObject>0</PhysicsObject>
  <PhysicsObjectSensor>0</PhysicsObjectSensor>
  <PhysicsObjectShape>0</PhysicsObjectShape>
  <PhysicsObjectDensity>0.5</PhysicsObjectDensity>
  <PhysicsObjectRestitution>0.100000001490116</PhysicsObjectRestitution>
  <PhysicsObjectGroup>0</PhysicsObjectGroup>
  <PhysicsObjectLinearDamping>0.100000001490116</PhysicsObjectLinearDamping>
  <PhysicsObjectAngularDamping>0.100000001490116</PhysicsObjectAngularDamping>
  <PhysicsObjectFriction>0.200000002980232</PhysicsObjectFriction>
  <PhysicsObjectAwake>-1</PhysicsObjectAwake>
  <PhysicsObjectKinematic>0</PhysicsObjectKinematic>
  <PhysicsShapePoints/>
</object>
