<!--This Document is generated by GameMaker, if you edit it by hand then you do so at your own risk!-->
<object>
  <spriteName>&lt;undefined&gt;</spriteName>
  <solid>0</solid>
  <visible>-1</visible>
  <depth>0</depth>
  <persistent>0</persistent>
  <parentName>&lt;undefined&gt;</parentName>
  <maskName>&lt;undefined&gt;</maskName>
  <events>
    <event eventtype="0" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Create actor
//Actions
hp=0;
target=noone;
//Flags
fOnGround=true; //Used to check if the actor is on the ground, to do specific things.
fGravity=true;
fGhost=false; //Turn on if you don't want the actor to have collision checking.
fVisible=true;
fShadow=true;
fEnemy=false; //Used by objEnemy.
fSolid=false;
fPushable=false; //Turn on if you want the actor to get pushed back when touching other actors.
fBounce=false; //Turn on if you want the actor to bounce from walls and floors. You can also change the bounciness value.
//Physics
z=9;
radius=4; //The radius is the actor's width split in half, i.e. 8 = 4.
height=16;
hSpeed=0;
vSpeed=0;
zSpeed=0;
spd=0;
bounciness=1; //Bounciness is calculated by spd divided by bounciness. Less is more.
faceDir=0;
sliding=false; //Used for sliding off of steep slopes.
//Collision
hitboxShape=-1;
hitbox=-1;
//Animation
shadowZ=-9;
shadowDir=0;
shadowPitch=0;
sprite=-1;
frame=0; //Similar to image_index.
frameSpd=0; //Similar to image_speed.
rotate=false; //Use rotate only if your sprite has 4 angles.
scale=1; //scale is used for changing the actor's sprite size. Does not affect hitbox.
emitter=audio_emitter_create();
audio_emitter_falloff(emitter,85.5,170.5,1);
timer_create();
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="1" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Clear used memory
actor_clear();
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="3" enumb="2">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Animation &amp; physics
//Keep the facing direction in range.
faceDir=angle_normalize(faceDir);
//Update sprite
actor_sprite_update();
//Shadow position
//The shadowZ will always be at -65536 if no floor is detected.
if (fShadow)
    if (c_raycast_world(x,y,z,x,y,z-65536,1))
        shadowZ=c_hit_z()+0.1;
    else
        shadowZ=-65536;
/*Physics
spd is a shortcut for setting hSpeed and vSpeed based on faceDir. You have to 
manually reset hSpeed and vSpeed if you want to stop the actor from moving.*/
if (spd!=0 &amp;&amp; !sliding)
{
    hSpeed=lengthdir_x(spd,faceDir);
    vSpeed=lengthdir_y(spd,faceDir);
}
//Actor collision
var actorTouch=instance_place(x,y,objActor);
//If there is a solid actor and I'm pushable...
if (actorTouch &amp;&amp; actorTouch.fSolid &amp;&amp; fPushable)
{
    var h=height*0.5,actorH=actorTouch.height*0.5,actorTop=actorTouch.z+actorH,
        actorBottom=actorTouch.z-actorH;
    //And if I am overlapping the actor...
    if (z-h&lt;actorTop &amp;&amp; z+h&gt;actorBottom)
    {
        //Move out of the way
        var angle=point_direction(x,y,actorTouch.x,actorTouch.y);
        hSpeed=lengthdir_x(-0.3,angle)+actorTouch.hSpeed;
        vSpeed=lengthdir_y(-0.3,angle)+actorTouch.vSpeed;
    }
}
//Adjust every speed based on delta time, This will save a lot of time
var hFinal=hSpeed*global.deltaTime,vFinal=vSpeed*global.deltaTime,
    zFinal=zSpeed*global.deltaTime;
if !(fGhost)
{
    //Step collision: If I'm on the ground or falling...
    if (zSpeed&lt;=0)
    {
        //Check for steps and slopes by raycasting from all edges
        var half=height*0.5,bottom=z-half,bottom2=bottom+4;
        if (c_raycast_world(x-radius,y-radius,bottom,x-radius+hFinal,y-radius+vFinal,bottom2,1) ||
            c_raycast_world(x+radius,y-radius,bottom,x+radius+hFinal,y-radius+vFinal,bottom2,1) ||
            c_raycast_world(x-radius,y+radius,bottom,x-radius+hFinal,y+radius+vFinal,bottom2,1) ||
            c_raycast_world(x+radius,y+radius,bottom,x+radius+hFinal,y+radius+vFinal,bottom2,1))
        {
            var zz=c_hit_z()+half;
            //Quick hack to check if it's not actually a tall wall
            if !(c_overlap_world_position(hitbox,c_hit_x(),c_hit_y(),zz+8))
                z=zz;
        }
    }
    //Horizontal collision
    if (c_overlap_world_position(hitbox,x+hFinal,y,z+1))
    {
        var hS=sign(hFinal);
        while (c_overlap_world_position(hitbox,x+hFinal,y,z+1) &amp;&amp;
               !c_overlap_world_position(hitbox,x+hS,y,z+1))
            x+=hS;
        if (fBounce)
            if (bounciness)
            {
                hSpeed/=-bounciness;
                hFinal=hSpeed*global.deltaTime;
            }
            else
            {
                hSpeed=0;
                hFinal=0;
            }
        else
        {
            hSpeed=0;
            hFinal=0;
            if (fEnemy)
                faceDir=irandom(360);
        }
    }
}
x+=hFinal;
//Vertical collision
if (!fGhost &amp;&amp; c_overlap_world_position(hitbox,x,y+vFinal,z+1))
{
    var vS=sign(vFinal);
    while (c_overlap_world_position(hitbox,x,y+vFinal,z+1) &amp;&amp;
           !c_overlap_world_position(hitbox,x,y+vS,z+1))
        y+=vS;
    if (fBounce)
        if (bounciness)
        {
            vSpeed/=-bounciness;
            vFinal=vSpeed*global.deltaTime;
        }
        else
        {
            vSpeed=0;
            vFinal=0;
        }
    else
    {
        vSpeed=0;
        vFinal=0;
        if (fEnemy)
            faceDir=irandom(360);
    }
}
y+=vFinal;
//Z-axis collision
if (!fGhost &amp;&amp; c_overlap_world_position(hitbox,x,y,z+zFinal))
{
    var zS=sign(zFinal);
    while (c_overlap_world_position(hitbox,x,y,z+zFinal) &amp;&amp;
        !c_overlap_world_position(hitbox,x,y,z+zS))
    z+=zS;
    fOnGround=true;
    actor_bounce_z();
    zFinal=zSpeed*global.deltaTime;
}
else
    fOnGround=false;
if (!fOnGround &amp;&amp; fGravity &amp;&amp; zSpeed&gt;-10)
    zSpeed-=0.1*global.deltaTime;
z+=zFinal;
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="3" enumb="1">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Update audio &amp; disappear in pits
audio_emitter_position(emitter,x,y,z);
if (z&lt;global.minZ-1024)
    instance_destroy();
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="7" enumb="5">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Clear used memory
instance_destroy();
</string>
          </argument>
        </arguments>
      </action>
    </event>
  </events>
  <PhysicsObject>0</PhysicsObject>
  <PhysicsObjectSensor>0</PhysicsObjectSensor>
  <PhysicsObjectShape>0</PhysicsObjectShape>
  <PhysicsObjectDensity>0.5</PhysicsObjectDensity>
  <PhysicsObjectRestitution>0.100000001490116</PhysicsObjectRestitution>
  <PhysicsObjectGroup>0</PhysicsObjectGroup>
  <PhysicsObjectLinearDamping>0.100000001490116</PhysicsObjectLinearDamping>
  <PhysicsObjectAngularDamping>0.100000001490116</PhysicsObjectAngularDamping>
  <PhysicsObjectFriction>0.200000002980232</PhysicsObjectFriction>
  <PhysicsObjectAwake>-1</PhysicsObjectAwake>
  <PhysicsObjectKinematic>0</PhysicsObjectKinematic>
  <PhysicsShapePoints/>
</object>
