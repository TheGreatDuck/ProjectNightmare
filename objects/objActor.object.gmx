<!--This Document is generated by GameMaker, if you edit it by hand then you do so at your own risk!-->
<object>
  <spriteName>&lt;undefined&gt;</spriteName>
  <solid>0</solid>
  <visible>-1</visible>
  <depth>0</depth>
  <persistent>0</persistent>
  <parentName>&lt;undefined&gt;</parentName>
  <maskName>&lt;undefined&gt;</maskName>
  <events>
    <event eventtype="0" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Create actor
//Actions
hp = 0;
target = noone;
//Flags
fOnGround = true; //Used to check if the actor is on the ground, to do specific things.
fGravity = true;
fGhost = false; //Turn on if you don't want the actor to have collision checking.
fVisible = true;
fShadow = true;
fEnemy = false; //Used by objEnemy.
fSolid = false;
fPushable = false; //Turn on if you want the actor to get pushed back when touching other actors.
fBounce = false; //Turn on if you want the actor to bounce from walls and floors. You can also change the bounciness value.
//Physics
z = 8;
radius = 4; //The radius is the actor's width split in half, i.e. 8 = 4.
height = 16;
half = 8; //The center point of the actor's height.
top = 16; //The bottom of the actor's z position.
bottom = 0; //The top of the z position.
hSpeed = 0;
vSpeed = 0;
zSpeed = 0;
spd = 0;
bounciness = 1; //Bounciness is calculated by spd divided by bounciness. Less is more.
faceDir = 0;
floorAngle = 0; //Used for checking the direction of slopes.
floorPitch = 0; //Used for checking the vertical angle of slopes and detecting steep surfaces.
sliding = false; //Used for sliding off of steep slopes.
//Animation
shadowZ = -9;
shadowMatrix = matrix_build(0, 0, 0, 0, 0, 0, 1, 1, 1);
sprite = -1;
frame = 0; //Similar to image_index.
frameSpd = 0; //Similar to image_speed.
rotate = false; //Use rotate only if your sprite has 4 angles.
scale = 1; //scale is used for changing the actor's sprite size. Does not affect hitbox.
emitter = audio_emitter_create();
audio_emitter_falloff(emitter, 85.5, 170.5, 1);
timer_create();
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="1" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Clear used memory
actor_clear();
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="7" enumb="25">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Animation &amp; physics
//Keep the facing direction in range.
faceDir = angle_normalize(faceDir);
//Update sprite
actor_sprite_update();
/*Shadow position
The shadowZ will always be at -65536 if no floor is detected.
NOTE: disabling an actor's shadow will also disable speed changing and sliding on slopes.*/
if (fShadow)
    if (c_raycast_world(x, y, z, x, y, z - 65536, 1))
    {
        shadowZ = c_hit_z() + 0.1;
        var normalX = c_hit_nx(), normalY = c_hit_ny(), normalZ = c_hit_nz();
        shadowMatrix = world_matrix_from_normal(c_hit_nx(), c_hit_ny(), normalZ, x, y, shadowZ, 1);
        floorAngle = abs(radtodeg(arctan2(normalY, normalX)) - 180)
        floorPitch = abs(radtodeg(arccos(-normalZ)) - 180);
    }
    else
    {
        shadowZ = -65536;
        floorPitch = 0;
    }
//Physics
//Actor collision
var actorTouch = instance_place(x, y, objActor);
//If there is a solid actor and I'm pushable... and if I am overlapping the actor...
if (actorTouch &amp;&amp; actorTouch.fSolid &amp;&amp; fPushable &amp;&amp; bottom &lt; actorTouch.top &amp;&amp; top &gt; actorTouch.bottom)
{
    //Move out of the way
    var angle = point_direction(x, y, actorTouch.x, actorTouch.y);
    hSpeed = lengthdir_x(-0.3, angle) + actorTouch.hSpeed;
    vSpeed = lengthdir_y(-0.3, angle) + actorTouch.vSpeed;
}
//Sliding on steep slopes
if (sliding)
    if (c_raycast_world(x, y, z, x, y, bottom - 8, 1) &amp;&amp; floorPitch)
    {
        z = c_hit_z() + half;
        var oppositeAngle = abs(floorAngle - 180);
        hSpeed = lengthdir_x(min(abs(hSpeed) + 0.1, abs(lengthdir_x(3, floorPitch))), oppositeAngle);
        vSpeed = lengthdir_y(min(abs(vSpeed) + 0.1, abs(lengthdir_y(3, floorPitch))), oppositeAngle);
    }
    else
        sliding = false;
else
{
    //spd is a shortcut for setting hSpeed and vSpeed based on faceDir. You have to 
    //manually reset hSpeed and vSpeed if you want to stop the actor from moving.
    if (spd != 0)
    {
        var realSpeed = spd;
        if (onGround &amp;&amp; floorPitch)
            realSpeed = lengthdir_x(spd, floorPitch);
        hSpeed = lengthdir_x(realSpeed, faceDir);
        vSpeed = lengthdir_y(realSpeed, faceDir);
    }
    if (fOnGround)
    {
        if (floorPitch &gt; 60)
        {
            hSpeed = 0;
            vSpeed = 0;
            zSpeed = 0;
            sliding = true;
        }
    }
    else
        if (fGravity &amp;&amp; zSpeed &gt; -10) //Gravity
            zSpeed -= 0.1;
}
//Collision
if !(fGhost)
{
    //Floor collision
    if (c_raycast_world(x, y, z, x + hSpeed, y + vSpeed, bottom + zSpeed, 1) || (!fBounce &amp;&amp; zSpeed &lt;= 0 &amp;&amp; c_raycast_world(x, y, z, x, y, bottom - (4 + zSpeed), 1)))
    {
        z = c_hit_z() + half;
        actor_bounce_z();
        fOnGround = true;
    }
    else
        fOnGround = false;
    //Horizontal wall collision
    var i;
    for (i = -radius; i &lt;= radius; i += radius)
    {
        if (i == 0)
            continue
        if (c_raycast_world(x, y, z, x + i + hSpeed, y, z, 1))
        {
            var dir = point_direction(x, y, c_hit_x(), c_hit_y());
            x = c_hit_x() - lengthdir_x(radius, dir);
            if (fBounce)
                hSpeed /= -bounciness;
            else
                hSpeed = 0;
            if (fEnemy)
                faceDir = irandom(360);
        }
    }
    //Vertical wall collision
    for (i = -radius; i &lt;= radius; i += radius)
    {
        if (i == 0)
            continue
        if (c_raycast_world(x, y, z, x, y + i + vSpeed, z, 1))
        {
            var dir = point_direction(x, y, c_hit_x(), c_hit_y());
            y = c_hit_y() - lengthdir_y(radius, dir);
            if (fBounce)
                vSpeed /= -bounciness;
            else
                vSpeed = 0;
            if (fEnemy)
                faceDir = irandom(360);
        }
    }
    //Ceiling collision
    if (c_raycast_world(x, y, z, x + hSpeed, y + vSpeed, top + zSpeed, 1))
    {
        var dir = point_direction(x, y, c_hit_x(), c_hit_y());
        x = xprevious;
        y = yprevious;
        z = c_hit_z() - half;
        hSpeed = 0;
        vSpeed = 0;
        if (zSpeed &gt; 0)
            if (fBounce)
                zSpeed = -zSpeed;
            else
                zSpeed = 0;
    }
}
x += hSpeed;
y += vSpeed;
z += zSpeed;
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="7" enumb="24">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Update audio, position &amp; disappear in pits
actor_update();
if (z &lt; global.minZ - 1024)
    instance_destroy();
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="7" enumb="5">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Clear used memory
instance_destroy();
</string>
          </argument>
        </arguments>
      </action>
    </event>
  </events>
  <PhysicsObject>0</PhysicsObject>
  <PhysicsObjectSensor>0</PhysicsObjectSensor>
  <PhysicsObjectShape>0</PhysicsObjectShape>
  <PhysicsObjectDensity>0.5</PhysicsObjectDensity>
  <PhysicsObjectRestitution>0.100000001490116</PhysicsObjectRestitution>
  <PhysicsObjectGroup>0</PhysicsObjectGroup>
  <PhysicsObjectLinearDamping>0.100000001490116</PhysicsObjectLinearDamping>
  <PhysicsObjectAngularDamping>0.100000001490116</PhysicsObjectAngularDamping>
  <PhysicsObjectFriction>0.200000002980232</PhysicsObjectFriction>
  <PhysicsObjectAwake>-1</PhysicsObjectAwake>
  <PhysicsObjectKinematic>0</PhysicsObjectKinematic>
  <PhysicsShapePoints/>
</object>
