<!--This Document is generated by GameMaker, if you edit it by hand then you do so at your own risk!-->
<object>
  <spriteName>&lt;undefined&gt;</spriteName>
  <solid>0</solid>
  <visible>-1</visible>
  <depth>0</depth>
  <persistent>0</persistent>
  <parentName>&lt;undefined&gt;</parentName>
  <maskName>&lt;undefined&gt;</maskName>
  <events>
    <event eventtype="0" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Create actor
//Actions
hp=0;
//Flags
fOnGround=true;
fGravity=true;
fGhost=false;
fVisible=true;
fShadow=true;
fEnemy=false;
fSolid=false;
fPushable=false;
fBounce=false;
//fPushable allows the actor to be pushed back when it touches a solid actor.
//Physics
z=9;
radius=4;
height=16;
hSpeed=0;
vSpeed=0;
zSpeed=0;
spd=0;
faceDir=0;
sliding=false;
//Collision
hitboxShape=-1;
hitbox=-1;
//Animation
shadowZ=-9;
shadowDir=0;
shadowPitch=0;
sprite=-1;
frame=0;
frameSpd=0;
rotate=false;
scale=1;
emitter=audio_emitter_create();
audio_emitter_falloff(emitter,85.5,170.5,1);
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="1" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Clear used memory
actor_clear();
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="3" enumb="2">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Animation &amp; physics
//Keep the facing direction in range.
faceDir=angle_normalize(faceDir);
/*Loop the animation every time the end is reached.
As a failsafe, check if the actor has a sprite. If not, abort.*/
if (sprite!=-1)
{
    var nums;
    if (rotate)
        nums=global.sFrames[sprite,0];
    else
        nums=global.sFrames[sprite,1];
    if (nums!=0)
        frame=(frame+frameSpd) mod (nums);
}
//Shadow position
if (fShadow)
    if (c_raycast_world(x,y,z,x,y,z-65536,1))
        shadowZ=c_hit_z()+0.1;
    else
        shadowZ=-65536;
//Physics
if (spd!=0 &amp;&amp; !sliding)
{
    hSpeed=lengthdir_x(spd,faceDir);
    vSpeed=lengthdir_y(spd,faceDir);
}
//Actor collision
var actorTouch=instance_place(x,y,objActor);
if (actorTouch &amp;&amp; actorTouch.fSolid &amp;&amp; fPushable)
{
    var h=height*0.5,actorH=actorTouch.height*0.5,actorTop=actorTouch.z+actorH,
        actorBottom=actorTouch.z-actorH;
    if (z-h&lt;actorTop &amp;&amp; z+h&gt;actorBottom)
    {
        var angle=point_direction(x,y,actorTouch.x,actorTouch.y);
        hSpeed=lengthdir_x(-0.3,angle)+actorTouch.hSpeed;
        vSpeed=lengthdir_y(-0.3,angle)+actorTouch.vSpeed;
    }
}
if !(fGhost)
{
    //Step collision
    if (zSpeed&lt;=0)
    {
        if (c_overlap_world_position(hitbox,x+hSpeed,y,z+1))
            for (var i=1;i&lt;5;i++)
                if !(c_overlap_world_position(hitbox,x+hSpeed,y,z+i+1))
                {
                    z+=i;
                    break
                }
        if (c_overlap_world_position(hitbox,x,y+vSpeed,z+1))
            for (var i=1;i&lt;5;i++)
                if !(c_overlap_world_position(hitbox,x,y+vSpeed,z+i+1))
                {
                    z+=i;
                    break
                }
    }
    if (c_overlap_world_position(hitbox,x+hSpeed,y,z+1))
    {
        var hS=sign(hSpeed);
        while (c_overlap_world_position(hitbox,x+hSpeed,y,z+1) &amp;&amp; !c_overlap_world_position(hitbox,x+hS,y,z+1))
            x+=hS;
        hSpeed=0;
        if (fBounce)
            faceDir=irandom(360);
    }
}
x+=hSpeed;
if (!fGhost &amp;&amp; c_overlap_world_position(hitbox,x,y+vSpeed,z+1))
{
    var vS=sign(vSpeed);
    while (c_overlap_world_position(hitbox,x,y+vSpeed,z+1) &amp;&amp; !c_overlap_world_position(hitbox,x,y+vS,z+1))
        y+=vS;
    vSpeed=0;
    if (fBounce)
        faceDir=irandom(360);
}
y+=vSpeed;
var zR=sign(zSpeed)*(height*0.5);
if !(fGhost)
{
    fOnGround=false;
    /*Slope collisions: these are objects instead of actual hitboxes. Because of Shaun
    Spalding's unstable collision code, I had to resort to this. As long as you put
    walls around slopes, there should be no weird bugs. Otherwise, if you touch a slope
    from above, you'll end up teleporting to the top of the slope.*/
    var x1=x-0.5,y1=y-0.5,x2=x+0.5,y2=y+0.5;
    var flor=collision_rectangle(x1,y1,x2,y2,objFloor,true,false);
    if (flor)
    {
        var inSlope=true,fX=flor.x,fY=flor.y,fW=flor.sprite_width,fH=flor.sprite_height,fA=flor.image_angle,fAD=fA-90;
        if (flor.object_index==objFloorAngled &amp;&amp; !rectangle_in_triangle(x1,y1,x2,y2,fX,fY,fX+lengthdir_x(fW,fA),fY+lengthdir_y(fW,fA),fX+lengthdir_x(fH,fAD),fY+lengthdir_y(fH,fAD)))
            inSlope=false;
        if (inSlope)
        {
            var fZ=flor.z,zStart,zDist,zDir,fDir=flor.dir;
            switch (fDir)
            {
                case (0):
                    zStart=x;
                    zDist=fX-x;
                    zDir=fW;
                break
                case (1):
                    zStart=y;
                    zDist=(fY+fH)-y;
                    zDir=fH;
                break
                case (2):
                    zStart=x;
                    zDist=(fX+fW)-x;
                    zDir=fW;
                break
                case (3):
                    zStart=y;
                    zDist=fY-y;
                    zDir=fH;
                break
            }
            var zH=height*0.5,zUp=abs(zDist)*(flor.height/zDir),zJump=max(0,zSpeed*2);
            //Check if the player is below the slope
            var fTop=fZ+zUp,zAngle=abs(point_direction(0,0,zDir,(fZ+flor.height)-fZ)-360);
            /*zJump is there to allow the actor to jump on slopes.
            If 2 * jumping speed is lower than 3, the actor won't be able to jump.*/
            if (z-zH-3+zJump&lt;fTop &amp;&amp; z+zH-zJump&gt;fTop)
            {
                z=zH+fTop;
                fOnGround=true;
                zSpeed=0;
                if (zAngle&gt;55)
                {
                    hSpeed-=(fDir==0)-(fDir==2);
                    vSpeed+=(fDir==1)-(fDir==3);
                    zSpeed=-1;
                    sliding=true;
                }
                else
                    sliding=false;
                zBlocked=true;
            }
            if (z-zH&gt;=fTop)
            {
                shadowZ=fTop+0.1;
                shadowDir=fDir;
                shadowPitch=zAngle;
            }
            else
                shadowPitch=0;
        }
        else
        {
            shadowPitch=0;
            sliding=false;
        }
    }
    else
    {
        shadowPitch=0;
        sliding=false;
    }
    if (!fOnGround &amp;&amp; c_overlap_world_position(hitbox,x,y,z+zSpeed))
    {
        var zS=sign(zSpeed);
        while (c_overlap_world_position(hitbox,x,y,z+zSpeed) &amp;&amp; !c_overlap_world_position(hitbox,x,y,z+zS))
            z+=zS;
        fOnGround=true;
        zSpeed=0;
    }
    if (!fOnGround &amp;&amp; fGravity &amp;&amp; zSpeed&gt;-10)
        zSpeed-=0.1;
}
z+=zSpeed;
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="3" enumb="1">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Set audio emitter position
audio_emitter_position(emitter,x,y,z);
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="7" enumb="5">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Clear used memory
instance_destroy();
</string>
          </argument>
        </arguments>
      </action>
    </event>
  </events>
  <PhysicsObject>0</PhysicsObject>
  <PhysicsObjectSensor>0</PhysicsObjectSensor>
  <PhysicsObjectShape>0</PhysicsObjectShape>
  <PhysicsObjectDensity>0.5</PhysicsObjectDensity>
  <PhysicsObjectRestitution>0.100000001490116</PhysicsObjectRestitution>
  <PhysicsObjectGroup>0</PhysicsObjectGroup>
  <PhysicsObjectLinearDamping>0.100000001490116</PhysicsObjectLinearDamping>
  <PhysicsObjectAngularDamping>0.100000001490116</PhysicsObjectAngularDamping>
  <PhysicsObjectFriction>0.200000002980232</PhysicsObjectFriction>
  <PhysicsObjectAwake>-1</PhysicsObjectAwake>
  <PhysicsObjectKinematic>0</PhysicsObjectKinematic>
  <PhysicsShapePoints/>
</object>
