<!--This Document is generated by GameMaker, if you edit it by hand then you do so at your own risk!-->
<object>
  <spriteName>&lt;undefined&gt;</spriteName>
  <solid>0</solid>
  <visible>-1</visible>
  <depth>0</depth>
  <persistent>0</persistent>
  <parentName>&lt;undefined&gt;</parentName>
  <maskName>&lt;undefined&gt;</maskName>
  <events>
    <event eventtype="0" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Create actor
//Actions
hp=0;
target=noone;
//Flags
fOnGround=true;
fGravity=true;
fGhost=false;
fVisible=true;
fShadow=true;
fEnemy=false;
fSolid=false;
fPushable=false;
fBounce=false;
//fPushable allows the actor to be pushed back when it touches a solid actor.
//Physics
z=9;
radius=4;
//The radius is the actor's width split in half, i.e. 8 = 4. This does not apply for
//height.
height=16;
hSpeed=0;
vSpeed=0;
zSpeed=0;
spd=0;
bounciness=1;
//Bounciness is calculated by spd divided by bounciness. Less is more.
faceDir=0;
sliding=false;
//Collision
hitboxShape=-1;
hitbox=-1;
//Animation
shadowZ=-9;
shadowDir=0;
shadowPitch=0;
sprite=-1;
frame=0;
frameSpd=0;
rotate=false;
scale=1;
emitter=audio_emitter_create();
audio_emitter_falloff(emitter,85.5,170.5,1);
timer_create();
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="1" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Clear used memory
actor_clear();
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="3" enumb="2">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Animation &amp; physics
//Keep the facing direction in range.
faceDir=angle_normalize(faceDir);
//Update sprite
actor_sprite_update();
//Shadow position
if (fShadow)
    if (c_raycast_world(x,y,z,x,y,z-65536,1))
        shadowZ=c_hit_z()+0.1;
    else
        shadowZ=-65536;
//Physics
if (spd!=0 &amp;&amp; !sliding)
{
    hSpeed=lengthdir_x(spd,faceDir);
    vSpeed=lengthdir_y(spd,faceDir);
}
//Actor collision
var actorTouch=instance_place(x,y,objActor);
if (actorTouch &amp;&amp; actorTouch.fSolid &amp;&amp; fPushable)
{
    var h=height*0.5,actorH=actorTouch.height*0.5,actorTop=actorTouch.z+actorH,
        actorBottom=actorTouch.z-actorH;
    if (z-h&lt;actorTop &amp;&amp; z+h&gt;actorBottom)
    {
        var angle=point_direction(x,y,actorTouch.x,actorTouch.y);
        hSpeed=lengthdir_x(-0.3,angle)+actorTouch.hSpeed;
        vSpeed=lengthdir_y(-0.3,angle)+actorTouch.vSpeed;
    }
}
var hFinal=hSpeed*global.deltaTime,vFinal=vSpeed*global.deltaTime,
    zFinal=zSpeed*global.deltaTime;
if !(sliding &amp;&amp; fGhost)
{
    //Step collision
    if (zSpeed&lt;=0)
    {
        if (c_overlap_world_position(hitbox,x+hFinal,y,z+1))
            for (var i=1;i&lt;5;i++)
                if !(c_overlap_world_position(hitbox,x+hFinal,y,z+i+1))
                {
                    z+=i;
                    break
                }
        if (c_overlap_world_position(hitbox,x,y+vFinal,z+1))
            for (var i=1;i&lt;5;i++)
                if !(c_overlap_world_position(hitbox,x,y+vFinal,z+i+1))
                {
                    z+=i;
                    break
                }
    }
    if (c_overlap_world_position(hitbox,x+hFinal,y,z+1))
    {
        var hS=sign(hFinal);
        while (c_overlap_world_position(hitbox,x+hFinal,y,z+1) &amp;&amp;
               !c_overlap_world_position(hitbox,x+hS,y,z+1))
            x+=hS;
        if (fBounce)
            if (bounciness)
            {
                hSpeed/=-bounciness;
                hFinal=hSpeed*global.deltaTime;
            }
            else
            {
                hSpeed=0;
                hFinal=0;
            }
        else
        {
            hSpeed=0;
            hFinal=0;
            if (fEnemy)
                faceDir=irandom(360);
        }
    }
}
x+=hFinal;
if (!sliding &amp;&amp; !fGhost &amp;&amp; c_overlap_world_position(hitbox,x,y+vFinal,z+1))
{
    var vS=sign(vFinal);
    while (c_overlap_world_position(hitbox,x,y+vFinal,z+1) &amp;&amp;
           !c_overlap_world_position(hitbox,x,y+vS,z+1))
        y+=vS;
    if (fBounce)
        if (bounciness)
        {
            vSpeed/=-bounciness;
            vFinal=vSpeed*global.deltaTime;
        }
        else
        {
            vSpeed=0;
            vFinal=0;
        }
    else
    {
        vSpeed=0;
        vFinal=0;
        if (fEnemy)
            faceDir=irandom(360);
    }
}
y+=vFinal;
var zR=sign(zFinal)*(height*0.5);
if !(fGhost)
{
    fOnGround=false;
    /*Slope collisions: these are objects instead of actual hitboxes. Because of Shaun
    Spalding's unstable collision code, I had to resort to this. As long as you put
    walls around slopes, there should be no weird bugs. Otherwise, if you touch a slope
    from above, you'll end up teleporting to the top of the slope.*/
    var x1=x-0.5,y1=y-0.5,x2=x+0.5,y2=y+0.5;
    var flor=collision_rectangle(x1,y1,x2,y2,objFloor,true,false);
    if (flor)
    {
        var inSlope=true,fX=flor.x,fY=flor.y,fW=flor.sprite_width,fH=flor.sprite_height,
            fA=flor.image_angle,fAD=fA-90;
        if (flor.object_index==objFloorAngled &amp;&amp; 
            !rectangle_in_triangle(x1,y1,x2,y2,fX,fY,fX+lengthdir_x(fW,fA),
                                   fY+lengthdir_y(fW,fA),fX+lengthdir_x(fH,fAD),
                                   fY+lengthdir_y(fH,fAD)))
            inSlope=false;
        if (inSlope)
        {
            var fZ=flor.z,zStart,zDist,zDir,fDir=flor.dir;
            switch (fDir)
            {
                case (0):
                    zStart=x;
                    zDist=fX-x;
                    zDir=fW;
                break
                case (1):
                    zStart=y;
                    zDist=(fY+fH)-y;
                    zDir=fH;
                break
                case (2):
                    zStart=x;
                    zDist=(fX+fW)-x;
                    zDir=fW;
                break
                case (3):
                    zStart=y;
                    zDist=fY-y;
                    zDir=fH;
                break
            }
            var zH=height*0.5,zUp=abs(zDist)*(flor.height/zDir),zJump=max(0,zSpeed*2);
            //Check if the player is below the slope
            var fTop=fZ+zUp,zAngle=abs(point_direction(0,0,zDir,(fZ+flor.height)-fZ)-360);
            //zJump is there to allow the actor to jump on slopes.
            //If 2 * jumping speed is lower than 3, the actor won't be able to jump.
            if (z-zH-3+zJump&lt;fTop &amp;&amp; z+zH-zJump&gt;fTop)
            {
                if (fBounce &amp;&amp; !sliding)
                    fOnGround=actor_bounce_z()==0;
                else
                {
                    z=zH+fTop;
                    zSpeed=0;
                    fOnGround=true;
                }
                zFinal=zSpeed*global.deltaTime;
                if (zAngle&gt;55)
                {
                    var slideX=(fDir==0)-(fDir==2),slideY=(fDir==1)-(fDir==3);
                    if (sliding)
                    {
                        hSpeed=clamp(hSpeed-slideX*0.1*global.deltaTime,-1,1);
                        vSpeed=clamp(vSpeed+slideY*0.1*global.deltaTime,-1,1);
                        zSpeed=-0.5*global.deltaTime;
                        zFinal=zSpeed*global.deltaTime;
                        faceDir=point_direction(0,0,-slideX,slideY);
                    }
                    else
                    {
                        hSpeed=0;
                        vSpeed=0;
                        sliding=true;
                        show_debug_message("Starting slide");
                    }
                }
                else
                    sliding=false;
            }
            if (z-zH&gt;=fTop)
            {
                shadowZ=fTop+0.1;
                shadowDir=fDir;
                shadowPitch=zAngle;
            }
            else
                shadowPitch=0;
        }
        else
        {
            shadowPitch=0;
            sliding=false;
        }
    }
    else
    {
        shadowPitch=0;
        sliding=false;
    }
    if !(fOnGround)
    {
        if (c_overlap_world_position(hitbox,x,y,z+zFinal))
        {
            var zS=sign(zFinal);
            while (c_overlap_world_position(hitbox,x,y,z+zFinal) &amp;&amp;
                !c_overlap_world_position(hitbox,x,y,z+zS))
            z+=zS;
            fOnGround=true;
            actor_bounce_z();
            zFinal=zSpeed*global.deltaTime;
        }
        if (fGravity &amp;&amp; zSpeed&gt;-10)
            zSpeed-=0.1*global.deltaTime;
    }
}
z+=zFinal;
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="3" enumb="1">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Update audio &amp; disappear in pits
audio_emitter_position(emitter,x,y,z);
if (z&lt;global.minZ-1024)
    instance_destroy();
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="7" enumb="5">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Clear used memory
instance_destroy();
</string>
          </argument>
        </arguments>
      </action>
    </event>
  </events>
  <PhysicsObject>0</PhysicsObject>
  <PhysicsObjectSensor>0</PhysicsObjectSensor>
  <PhysicsObjectShape>0</PhysicsObjectShape>
  <PhysicsObjectDensity>0.5</PhysicsObjectDensity>
  <PhysicsObjectRestitution>0.100000001490116</PhysicsObjectRestitution>
  <PhysicsObjectGroup>0</PhysicsObjectGroup>
  <PhysicsObjectLinearDamping>0.100000001490116</PhysicsObjectLinearDamping>
  <PhysicsObjectAngularDamping>0.100000001490116</PhysicsObjectAngularDamping>
  <PhysicsObjectFriction>0.200000002980232</PhysicsObjectFriction>
  <PhysicsObjectAwake>-1</PhysicsObjectAwake>
  <PhysicsObjectKinematic>0</PhysicsObjectKinematic>
  <PhysicsShapePoints/>
</object>
