<!--This Document is generated by GameMaker, if you edit it by hand then you do so at your own risk!-->
<object>
  <spriteName>&lt;undefined&gt;</spriteName>
  <solid>0</solid>
  <visible>-1</visible>
  <depth>0</depth>
  <persistent>0</persistent>
  <parentName>&lt;undefined&gt;</parentName>
  <maskName>&lt;undefined&gt;</maskName>
  <events>
    <event eventtype="0" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Create actor
//Actions
hp=0;
//Flags
fOnGround=true;
fOnSlope=false;
fGravity=true;
fGhost=false;
fVisible=true;
fShadow=true;
fEnemy=false;
//Physics
z=9;
radius=4;
height=16;
hSpeed=0;
vSpeed=0;
zSpeed=0;
spd=0;
faceDir=0;
sliding=false;
//Collision
hitboxShape=-1;
hitbox=-1;
//Animation
shadowZ=-9;
shadowDir=0;
shadowPitch=0;
sprite=-1;
frame=0;
frameSpd=0;
rotate=false;
emitter=audio_emitter_create();
audio_emitter_falloff(emitter,85.5,170.5,1);
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="1" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Clear used memory
actor_clear();
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="3" enumb="2">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Animation &amp; physics
//Keep the facing direction in range.
faceDir=angle_normalize(faceDir);
/*Loop the animation every time the end is reached.
As a failsafe, check if the actor has a sprite. If not, abort.*/
if (sprite!=-1)
{
    var nums;
    if (rotate)
        nums=global.sFrames[sprite,0];
    else
        nums=global.sFrames[sprite,1];
    frame=(frame+frameSpd) mod (nums);
}
//Shadow position
if (fShadow)
    if (c_raycast_world(x,y,z,x,y,z-65536,1))
        shadowZ=c_hit_z()+0.1;
    else
        shadowZ=-65536;
//Physics
if (spd!=0)
{
    hSpeed=lengthdir_x(spd,faceDir);
    vSpeed=lengthdir_y(spd,faceDir);
}
if (!fGhost &amp;&amp; c_overlap_world_position(hitbox,x+hSpeed,y+vSpeed,z+1))
    for (var i=1;i&lt;5+fOnSlope;i++)
        if !(c_overlap_world_position(hitbox,x+hSpeed,y+vSpeed,z+i+1))
        {
            z+=i;
            break
        }
if (!fGhost &amp;&amp; c_overlap_world_position(hitbox,x+hSpeed,y,z+1))
{
    var hS=sign(hSpeed);
    while (c_overlap_world_position(hitbox,x+hSpeed,y,z+1) &amp;&amp; 
           !c_overlap_world_position(hitbox,x+hS,y,z+1))
        x+=hS;
    hSpeed=0;
}
x+=hSpeed;
if (!fGhost &amp;&amp; c_overlap_world_position(hitbox,x,y+vSpeed,z+1))
{
    var vS=sign(vSpeed);
    while (c_overlap_world_position(hitbox,x,y+vSpeed,z+1) &amp;&amp; 
           !c_overlap_world_position(hitbox,x,y+vS,z+1))
        y+=vS;
    vSpeed=0;
}
y+=vSpeed;
var zR=sign(zSpeed)*(height*0.5);
if !(fGhost)
{
    fOnGround=false;
    /*Slope collisions: these are objects instead of actual hitboxes. Because of Shaun
    Spalding's unstable collision code, I had to resort to this. As long as you put
    walls around slopes, there should be no weird bugs. Otherwise, if you touch a slope
    from above, you'll end up teleporting to the top of the slope.*/
    var flor=collision_rectangle(x-0.5,y-0.5,x+0.5,y+0.5,objFloor,true,false);
    if (flor)
    {
        var fX=flor.x,fY=flor.y,fZ=flor.z,fW=flor.sprite_width,fH=flor.sprite_height,
            zStart,zDist,zDir,fDir=flor.dir;
        switch (fDir)
        {
            case (0):
                zStart=x;
                zDist=fX-x;
                zDir=fW;
            break
            case (1):
                zStart=y;
                zDist=(fY+fH)-y;
                zDir=fH;
            break
            case (2):
                zStart=x;
                zDist=(fX+fW)-x;
                zDir=fW;
            break
            case (3):
                zStart=y;
                zDist=fY-y;
                zDir=fH;
            break
        }
        var zH=height*0.5,zUp=abs(zDist)*(flor.height/zDir),zJump=max(0,zSpeed*2);
        //Check if the player is below the slope
        var fTop=fZ+zUp,zAngle=abs(point_direction(0,0,zDir,(fZ+flor.height)-fZ)-360);
        /*zJump is there to allow the actor to jump on slopes.
        If 2 * jumping speed is lower than 3, the actor won't be able to jump.*/
        if (z-zH-3+zJump&lt;fTop &amp;&amp; z+zH-zJump&gt;fTop)
        {
            z=zH+fTop;
            fOnGround=true;
            fOnSlope=true;
            zSpeed=0;
            if (zAngle&gt;55)
            {
                hSpeed-=(fDir==0)-(fDir==2);
                vSpeed+=(fDir==1)-(fDir==3);
                zSpeed=-1;
                sliding=true;
            }
            else
                sliding=false;
        }
        else
            fOnSlope=false;
        if (z-zH&gt;=fTop)
        {
            shadowZ=fTop+0.1;
            shadowDir=fDir;
            shadowPitch=zAngle;
        }
        else
            shadowPitch=0;
    }
    else
    {
        shadowPitch=0;
        sliding=false;
        fOnSlope=false;
    }
    if (!fOnGround &amp;&amp; c_overlap_world_position(hitbox,x,y,z+zSpeed))
    {
        var zS=sign(zSpeed);
        while (c_overlap_world_position(hitbox,x,y,z+zSpeed) &amp;&amp; 
            !c_overlap_world_position(hitbox,x,y,z+zS))
        z+=zS;
        fOnGround=true;
        zSpeed=0;
    }
    if (!fOnGround &amp;&amp; fGravity &amp;&amp; zSpeed&gt;-10)
        zSpeed-=0.1;
}
z+=zSpeed;
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="3" enumb="1">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Set audio emitter position
audio_emitter_position(emitter,x,y,z);
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="7" enumb="5">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Clear used memory
instance_destroy();
</string>
          </argument>
        </arguments>
      </action>
    </event>
  </events>
  <PhysicsObject>0</PhysicsObject>
  <PhysicsObjectSensor>0</PhysicsObjectSensor>
  <PhysicsObjectShape>0</PhysicsObjectShape>
  <PhysicsObjectDensity>0.5</PhysicsObjectDensity>
  <PhysicsObjectRestitution>0.100000001490116</PhysicsObjectRestitution>
  <PhysicsObjectGroup>0</PhysicsObjectGroup>
  <PhysicsObjectLinearDamping>0.100000001490116</PhysicsObjectLinearDamping>
  <PhysicsObjectAngularDamping>0.100000001490116</PhysicsObjectAngularDamping>
  <PhysicsObjectFriction>0.200000002980232</PhysicsObjectFriction>
  <PhysicsObjectAwake>-1</PhysicsObjectAwake>
  <PhysicsObjectKinematic>0</PhysicsObjectKinematic>
  <PhysicsShapePoints/>
</object>
