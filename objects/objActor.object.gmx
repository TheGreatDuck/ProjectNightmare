<!--This Document is generated by GameMaker, if you edit it by hand then you do so at your own risk!-->
<object>
  <spriteName>&lt;undefined&gt;</spriteName>
  <solid>0</solid>
  <visible>-1</visible>
  <depth>0</depth>
  <persistent>0</persistent>
  <parentName>&lt;undefined&gt;</parentName>
  <maskName>&lt;undefined&gt;</maskName>
  <events>
    <event eventtype="0" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Create actor
//Actions
hp=0;
target=noone;
//Flags
fOnGround=true;
fGravity=true;
fGhost=false;
fVisible=true;
fShadow=true;
fEnemy=false;
fSolid=false;
fPushable=false;
fBounce=false;
//fPushable allows the actor to be pushed back when it touches a solid actor.
//Physics
z=9;
radius=4;
//The radius is the actor's width split in half, i.e. 8 = 4. This does not apply for
//height.
height=16;
hSpeed=0;
vSpeed=0;
zSpeed=0;
spd=0;
bounciness=1;
//Bounciness is calculated by spd divided by bounciness. Less is more.
faceDir=0;
sliding=false;
//Collision
hitboxShape=-1;
hitbox=-1;
//Animation
shadowZ=-9;
shadowDir=0;
shadowPitch=0;
sprite=-1;
frame=0;
frameSpd=0;
rotate=false;
scale=1;
emitter=audio_emitter_create();
audio_emitter_falloff(emitter,85.5,170.5,1);
timer_create();
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="1" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Clear used memory
actor_clear();
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="3" enumb="2">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Animation &amp; physics
//Keep the facing direction in range.
faceDir=angle_normalize(faceDir);
//Update sprite
actor_sprite_update();
//Shadow position
if (fShadow)
    if (c_raycast_world(x,y,z,x,y,z-65536,1))
        shadowZ=c_hit_z()+0.1;
    else
        shadowZ=-65536;
//Physics
if (spd!=0 &amp;&amp; !sliding)
{
    hSpeed=lengthdir_x(spd,faceDir);
    vSpeed=lengthdir_y(spd,faceDir);
}
//Actor collision
var actorTouch=instance_place(x,y,objActor);
if (actorTouch &amp;&amp; actorTouch.fSolid &amp;&amp; fPushable)
{
    var h=height*0.5,actorH=actorTouch.height*0.5,actorTop=actorTouch.z+actorH,
        actorBottom=actorTouch.z-actorH;
    if (z-h&lt;actorTop &amp;&amp; z+h&gt;actorBottom)
    {
        var angle=point_direction(x,y,actorTouch.x,actorTouch.y);
        hSpeed=lengthdir_x(-0.3,angle)+actorTouch.hSpeed;
        vSpeed=lengthdir_y(-0.3,angle)+actorTouch.vSpeed;
    }
}
var hFinal=hSpeed*global.deltaTime,vFinal=vSpeed*global.deltaTime,
    zFinal=zSpeed*global.deltaTime;
if !(fGhost)
{
    //Step collision
    if (zSpeed&lt;=0)
    {
        var half=height*0.5,bottom=z-half,bottom2=bottom+4;
        if (c_raycast_world(x-radius,y-radius,bottom,x-radius+hFinal,y-radius+vFinal,bottom2,1) ||
            c_raycast_world(x+radius,y-radius,bottom,x+radius+hFinal,y-radius+vFinal,bottom2,1) ||
            c_raycast_world(x-radius,y+radius,bottom,x-radius+hFinal,y+radius+vFinal,bottom2,1) ||
            c_raycast_world(x+radius,y+radius,bottom,x+radius+hFinal,y+radius+vFinal,bottom2,1))
        {
            var zz=c_hit_z()+half;
            if !(c_overlap_world_position(hitbox,c_hit_x(),c_hit_y(),zz+8))
                z=zz;
        }
    }
    if (c_overlap_world_position(hitbox,x+hFinal,y,z+1))
    {
        var hS=sign(hFinal);
        while (c_overlap_world_position(hitbox,x+hFinal,y,z+1) &amp;&amp;
               !c_overlap_world_position(hitbox,x+hS,y,z+1))
            x+=hS;
        if (fBounce)
            if (bounciness)
            {
                hSpeed/=-bounciness;
                hFinal=hSpeed*global.deltaTime;
            }
            else
            {
                hSpeed=0;
                hFinal=0;
            }
        else
        {
            hSpeed=0;
            hFinal=0;
            if (fEnemy)
                faceDir=irandom(360);
        }
    }
}
x+=hFinal;
if (!sliding &amp;&amp; !fGhost &amp;&amp; c_overlap_world_position(hitbox,x,y+vFinal,z+1))
{
    var vS=sign(vFinal);
    while (c_overlap_world_position(hitbox,x,y+vFinal,z+1) &amp;&amp;
           !c_overlap_world_position(hitbox,x,y+vS,z+1))
        y+=vS;
    if (fBounce)
        if (bounciness)
        {
            vSpeed/=-bounciness;
            vFinal=vSpeed*global.deltaTime;
        }
        else
        {
            vSpeed=0;
            vFinal=0;
        }
    else
    {
        vSpeed=0;
        vFinal=0;
        if (fEnemy)
            faceDir=irandom(360);
    }
}
y+=vFinal;
if (!fGhost &amp;&amp; c_overlap_world_position(hitbox,x,y,z+zFinal))
{
    var zS=sign(zFinal);
    while (c_overlap_world_position(hitbox,x,y,z+zFinal) &amp;&amp;
        !c_overlap_world_position(hitbox,x,y,z+zS))
    z+=zS;
    fOnGround=true;
    actor_bounce_z();
    zFinal=zSpeed*global.deltaTime;
}
else
    fOnGround=false;
if (!fOnGround &amp;&amp; fGravity &amp;&amp; zSpeed&gt;-10)
    zSpeed-=0.1*global.deltaTime;
z+=zFinal;
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="3" enumb="1">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Update audio &amp; disappear in pits
audio_emitter_position(emitter,x,y,z);
if (z&lt;global.minZ-1024)
    instance_destroy();
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="7" enumb="5">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Clear used memory
instance_destroy();
</string>
          </argument>
        </arguments>
      </action>
    </event>
  </events>
  <PhysicsObject>0</PhysicsObject>
  <PhysicsObjectSensor>0</PhysicsObjectSensor>
  <PhysicsObjectShape>0</PhysicsObjectShape>
  <PhysicsObjectDensity>0.5</PhysicsObjectDensity>
  <PhysicsObjectRestitution>0.100000001490116</PhysicsObjectRestitution>
  <PhysicsObjectGroup>0</PhysicsObjectGroup>
  <PhysicsObjectLinearDamping>0.100000001490116</PhysicsObjectLinearDamping>
  <PhysicsObjectAngularDamping>0.100000001490116</PhysicsObjectAngularDamping>
  <PhysicsObjectFriction>0.200000002980232</PhysicsObjectFriction>
  <PhysicsObjectAwake>-1</PhysicsObjectAwake>
  <PhysicsObjectKinematic>0</PhysicsObjectKinematic>
  <PhysicsShapePoints/>
</object>
