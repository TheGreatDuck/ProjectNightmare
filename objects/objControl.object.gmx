<!--This Document is generated by GameMaker, if you edit it by hand then you do so at your own risk!-->
<object>
  <spriteName>&lt;undefined&gt;</spriteName>
  <solid>0</solid>
  <visible>-1</visible>
  <depth>0</depth>
  <persistent>0</persistent>
  <parentName>&lt;undefined&gt;</parentName>
  <maskName>&lt;undefined&gt;</maskName>
  <events>
    <event eventtype="0" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Load game
discord_init_dll();
discord_init_app("732560402873057320");
draw_set_circle_precision(64);
d3d_set_perspective(true);
d3d_set_hidden(true);
d3d_set_culling(true);
d3d_set_shading(false);
draw_set_alpha_test(true);
draw_set_alpha_test_ref_value(0);
audio_falloff_set_model(audio_falloff_exponent_distance);
global.maxRender = 65536;
/*[CONTROL BINDS]
These are used by control to detect inputs. The 2D array indices are as follows:
0 = keyboard bind
1 = gamepad bind
2 = held
3 = pressed
4 = released
5 = axis, positive
6 = axis, negative
(Movement)*/
global.gamepad = false;
global.bind[0, 0] = ord("W"); //Up
global.bind[0, 1] = gp_axislv;
global.bind[1, 0] = ord("A"); //Left
global.bind[1, 1] = gp_axislh;
global.bind[2, 0] = ord("S"); //Down
global.bind[2, 1] = gp_axislv;
global.bind[3, 0] = ord("D"); //Right
global.bind[3, 1] = gp_axislh;
global.bind[4, 0] = vk_space; //Jump
global.bind[4, 1] = gp_face1;
global.bind[5, 0] = ord("X"); //Slidekick
global.bind[5, 1] = gp_face2;
global.bind[6, 0] = ord("E"); //Interact
global.bind[6, 1] = gp_face3;
global.bind[7, 0] = ord("Q"); //Make camera look from player
global.bind[7, 1] = gp_face4;
//(Camera)
global.bind[8, 0] = mb_left; //Free scroll
global.bind[8, 1] = gp_shoulderl;
global.bind[9, 0] = mb_right; //First person
global.bind[9, 1] = gp_shoulderr;
global.bind[10, 1] = gp_axisrv; //Camera up
global.bind[11, 1] = gp_axisrh; //Camera left
global.bind[12, 1] = gp_axisrv; //Camera down
global.bind[13, 1] = gp_axisrh; //Camera right
for (var i = 0; i &lt; 14; i++) for (var j = 2; j &lt; 7; j++) global.bind[i, j] = false;
/*[ASSETS]
All game assets are externalized and stored in a ZIP file. The asset maps are as follows:
global.spr = sprites/models (coming soon)
global.bg = backgrounds
global.tex = textures
global.mtl = materials
global.fnt = fonts (coming soon)
global.snd = sounds
global.mus = music
---
Extract all assets from data.zip.
If your game gives an error that is related to a missing asset, you'll have to redownload data.zip.
Just for the sake of debugging, we disabled path checking.*/
directory_destroy("data");
zip_unzip("data.zip", game_save_id);
//Prepare Custom Sprite Framework for loading sprites and backgrounds
image_system_init();
image_group_create("spr");
image_group_create("bg");
image_group_create("tex");
image_group_create("mtl");
smf_init();
var assets = 0; /*Temporary variable for counting current asset types
---SPRITES---
They are mostly used by the GUI and Actors.
The sprite files are located in data\gfx\spr and MUST be PNGs and numbered.
Example: 0.png, 1.png, 2.png...

"ani.txt" contains sprite definitions, where every line is formatted like this:
    Defining a normal/rotatable sprite: sprite|frames|rotates|x offset|y offset

Models are also stored in the sprite list structure. They are put in numbered folders and use Snidr's Model Format.
Each model folder contains:
    -Submodels (.smf files numbered from 0) that make the whole model. You can assign skins to them that define which material they should use. You can hide the submodel by setting its skin to -1.
    -Bodygroups (x\y.smf, where x is the ID and y is the value, both are numbered from 0) that display a part on the model based on their value. You can only assign one material per bodygroup. You can hide the bodygroup by setting its value to -1.
    -Animations (.ani files numbered from 0). You can assign 

"mdl.txt", contains model information, where every line is formatted like this:
    Defining a submodel: 0|submodel ID|skin 0 material ID...
    Defining a bodygroup: 1|bodygroup ID|material ID
    Defining an animation: 2|animation ID|frame cycle type|frames
                           Animation frame cycle types: 0 = linear
                                                        1 = linear, loop
                                                        2 = quadratic
                                                        3 = quadratic, loop

The sprite list structure is as follows:
global.spr[| id] = a list containing sprite data:
    0 = the sprite itself (model list if sprite type is 2)
        The model list structure is as follows:
        0 = submodels list:
            0... = submodel list:
                   0 = model pointer
                   1... = skin material
        1 = bodygroups list:
            0... = bodygroup list:
                   0 = material
                   1... = model pointer
        2... = animation index list:
            0 = animation index
            1 = frame cycle type
            2... = frame sample
    1 = sprite type:
        0 = normal
        1 = 4-directional
        2 = billboard
        3 = static model
        4 = animated model
    2... = sprite as texture pointers (undefined if sprite is a model)*/
global.spr = ds_list_create();
image_stream_start("spr", 2048, 2048, 0, true, false);
var file = file_find_first(cDirSpr + "*.png", 0), tempData = ds_priority_create();
while (file != "")
{
    var list = ds_list_create(), slot = string_digits(file), table = file_text_open_read(cDirSpr + "ani.txt"), frames = 1, rotates = false, xOfs = 0, yOfs = 0, info;
    while !(file_text_eof(table)) //Look for animation data in the animation data table
    {
        info = string_parse(level_read_string(table));
        if (info[| 0] == slot) //If the parsed string belongs to this sprite...
        {
            frames = real(info[| 1]); //Set amount of frames this sprite has
            rotates = real(info[| 2]); //Set "rotatable" flag for sprite
            xOfs = real(info[| 3]); //Set X offset of sprite
            yOfs = real(info[| 4]); //Set Y offset of sprite
            ds_list_destroy(info);
            break
        }
        ds_list_destroy(info);
    }
    //Close the lookup table after and add the sprites to the atlas
    file_text_close(table);
    image_stream_add_3d("spr", slot, cDirSpr + file, frames, xOfs, yOfs);
    ds_list_add(list, "sprite", rotates);
    ds_priority_add(tempData, list, real(slot));
    file = file_find_next();
}
file_find_close();
image_stream_finish("spr");
//Prepare model lists
var file = file_find_first(cDirSpr + "*", fa_directory);
while (file != "")
{
    if (string_letters(file) != "") //Stupid workaround (why is it looking for files too when it's specifically set to look for FOLDERS???)
    {
        file = file_find_next();
        continue
    }
    var addModel = ds_list_create(), addModel2 = ds_list_create();
    ds_list_add(addModel2, ds_list_create(), ds_list_create());
    //Check for animations. All models are static by default unless the model definitions file has an animation defined
    var modelType = 3, table = file_text_open_read(cDirSpr + file + "\mdl.txt");
    while !(file_text_eof(table)) if (string_copy(level_read_string(table), 1, 1) == "2")
    {
        modelType = 4;
        break
    }
    ds_list_add(addModel, addModel2, modelType);
    ds_priority_add(tempData, addModel, real(file));
    file = file_find_next();
}
file_find_close();
//Add streamed sprites and empty model lists to the sprite list structure
i = 0;
repeat (ds_priority_size(tempData))
{
    var list = ds_priority_find_min(tempData);
    if (list[| 0] == "sprite")
    {
        ds_list_replace(list, 0, image_group_find_image("spr", string(i)));
        for (var j = 0, p = list[| 0]; j &lt; image_get_number(p); j++) ds_list_add(list, image_get_texture(p, j)); //Add frames to sprite data list
    }
    ds_list_add(global.spr, list);
    ds_priority_delete_min(tempData);
    i++;
}
//Load model data for each model list
for (i = 0; i &lt; ds_list_size(global.spr); i++)
{
    var modelType = sprite_type(i);
    if (modelType &lt; 3) continue //Skip non-models
    var modelList = sprite_get(i), submodelsList = modelList[| 0], bodygroupsList = modelList[| 1], modelSlot = string(i), folder = cDirSpr + modelSlot + "\";
    //Load submodels
    file = file_find_first(folder + "*.smf", 0);
    while (file != "")
    {
        var list = ds_list_create(), slot = string_digits(file), table = file_text_open_read(folder + "mdl.txt"), info;
        ds_list_add(list, smf_model_load(folder + file));
        while !(file_text_eof(table)) //Look for skins data in the model data table
        {
            str = level_read_string(table);
            if (string_copy(str, 1, 1) != "0") continue //Ignore all strings that don't have the "submodel" header (0)
            info = string_parse(str);
            if (info[| 1] == slot) //If the parsed string belongs to this submodel...
            {
                for (var j = 2; j &lt; ds_list_size(info); j++) ds_list_add(list, real(info[| j])); //Add all skins from the list
                ds_list_destroy(info);
                break
            }
            ds_list_destroy(info);
        }
        file_text_close(table);
        ds_list_insert(submodelsList, real(slot), list);
        file = file_find_next();
    }
    file_find_close();
    //Load bodygroup materials
    file = file_find_first(folder + "*", fa_directory);
    while (file != "")
    {
        if (string_letters(file) != "") //Stupid workaround (why is it looking for files too when it's specifically set to look for FOLDERS???)
        {
            file = file_find_next();
            continue
        }
        var list = ds_list_create(), table = file_text_open_read(folder + "mdl.txt"), info;
        while !(file_text_eof(table)) //Look for bodygroups data in the model data table
        {
            str = level_read_string(table);
            if (string_copy(str, 1, 1) != "1") continue //Ignore all strings that don't have the "bodygroup" header (1)
            info = string_parse(str);
            if (info[| 1] == file) //If the parsed string belongs to this bodygroup...
            {
                ds_list_add(list, real(info[| 2])); //Add bodygroup material from parsed string
                ds_list_destroy(info);
                break
            }
            ds_list_destroy(info);
        }
        file_text_close(table);
        ds_list_insert(bodygroupsList, real(file), list);
        file = file_find_next();
    }
    file_find_close();
    //Load bodygroup models
    for (j = 0; j &lt; ds_list_size(bodygroupsList); j++)
    {
        var bodygroupFolder = folder + string(j) + "\";
        file = file_find_first(bodygroupFolder + "*.smf", 0);
        while (file != "")
        {
            var slot = string_digits(file);
            ds_list_insert(bodygroupsList[| j], 1 + real(slot), smf_model_load(bodygroupFolder + file));
            file = file_find_next();
        }
        file_find_close();
    }
    //Load animations
    if (modelType == 4)
    {
        file = file_find_first(folder + "*.ani", 0);
        while (file != "")
        {
            var animation = smf_animation_load(folder + file), list = ds_list_create(), slot = string_digits(file), table = file_text_open_read(folder + "mdl.txt"), info, type, frames;
            while !(file_text_eof(table)) //Look for animation data in the model data table
            {
                str = level_read_string(table);
                if (string_copy(str, 1, 1) != "2") continue //Ignore all strings that don't have the "animation" header (2)
                info = string_parse(str);
                if (info[| 1] == slot) //If the parsed string belongs to this submodel...
                {
                    type = real(info[| 2]); //Get animation keyframe cycle type
                    frames = real(info[| 3]); //Get animation keyframes amount
                    ds_list_destroy(info);
                    break
                }
                ds_list_destroy(info);
            }
            file_text_close(table);
            ds_list_add(list, animation, type);
            for (j = 0; j &lt; frames; j++) ds_list_add(list, smf_sample_create(animation, type, j / frames));
            ds_priority_add(tempData, list, real(slot));
            file = file_find_next();
        }
        file_find_close();
        repeat (ds_priority_size(tempData))
        {
            ds_list_add(modelList, ds_priority_find_min(tempData));
            ds_priority_delete_min(tempData);
        }
    }
}
ds_priority_destroy(tempData);
/*---BACKGROUNDS---
They have no frames at all, so we can store way less data than sprites or textures.
The background files are located in data\gfx\bg and MUST be PNGs and numbered.
Example: 0.png, 1.png, 2.png...

The background list structure is as follows:
global.bg[| id] = the pointer of the background graphic*/
global.bg = ds_list_create();
image_stream_start("bg", 1024, 1024, 0, true, false);
file = file_find_first(cDirBg + "*.png", 0);
while (file != "")
{
    image_stream_add("bg", string_digits(file), cDirBg + file, 1, 0, 0);
    //Increment the total backgrounds count and find the next background
    assets++;
    file = file_find_next();
}
file_find_close();
image_stream_finish("bg");
for (i = 0; i &lt; assets; i++) ds_list_add(global.bg, image_group_find_image("bg", string(i)));
assets = 0;
/*---TEXTURES---
Textures are used by levels, which means all the level texture handling is done by PN Editor and no pointer enums are needed.
The texture files are located in data\gfx\tex and MUST be PNGs and numbered.
Example: 0.png, 1.png, 2.png...

"ani.txt" contains texture definitions, where every line is formatted like this: texture|frames|speed

The sprite list structure is as follows:
global.tex[? id] = a list containing texture data:
    0 = pointer of graphic
    1 = animation speed
    2... = the graphic as separate texture pointer(s)*/
tempData = ds_list_create();
global.tex = ds_list_create();
image_stream_start("tex", 1024, 1024, 0, true, false);
file = file_find_first(cDirTex + "*.png", 0);
while (file != "")
{
    var slot = string_digits(file), table = file_text_open_read(cDirTex + "ani.txt"), frames = 1, spd = 1, info;
    while !(file_text_eof(table)) //Look for animation data in the animation data table
    {
        info = string_parse(file_text_read_string(table));
        if (info[| 0] == slot) //If the parsed string belongs to this texture...
        {
            frames = real(info[| 1]); //Set amount of frames this texture has
            spd = real(info[| 2]); //Animation speed
            ds_list_destroy(info);
            break
        }
        ds_list_destroy(info);
        file_text_readln(table);
    }
    //Close the lookup table after and add the texture to the atlas
    file_text_close(table);
    image_stream_add_3d("tex", slot, cDirTex + file, frames, 0, 0);
    ds_list_insert(tempData, real(slot), spd);
    //Increment the total textures count and find the next background
    assets++;
    file = file_find_next();
}
file_find_close();
image_stream_finish("tex");
for (i = 0; i &lt; assets; i++)
{
    var texData = ds_list_create();
    ds_list_add(texData, image_group_find_image("tex", string(i)), tempData[| i]);
    for (var j = 0, p = texData[| 0]; j &lt; image_get_number(p); j++) ds_list_add(texData, image_get_texture(p, j)); //Add frames to texture data list
    ds_list_add(global.tex, texData);
}
ds_list_destroy(tempData);
assets = 0;
/*---MATERIALS---
Materials are textures used by models. They have no frames at all, so we can store them
similarly to backgrounds; both have way less data to go through than sprites or textures.
If you add some extra code, you can assign a shader for each material to make it shiny, for example.

The material files are located in data\gfx\mtl and MUST be PNGs and numbered.
Example: 0.png, 1.png, 2.png...

The material list structure is as follows:
global.mtl[| id] = the material's texture pointer*/
global.mtl = ds_list_create();
image_stream_start("mtl", 1024, 1024, 0, true, false);
file = file_find_first(cDirMtl + "*.png", 0);
while (file != "")
{
    image_stream_add_3d("mtl", string_digits(file), cDirMtl + file, 1, 0, 0);
    //Increment the total backgrounds count and find the next background
    assets++;
    file = file_find_next();
}
file_find_close();
image_stream_finish("mtl");
for (i = 0; i &lt; assets; i++) ds_list_add(global.mtl, image_get_texture(image_group_find_image("mtl", string(i)), 0));
assets = 0;
/*---SOUNDS---
The sound files are located in data\sfx\ and MUST be OGGs and numbered.
Example: 0.ogg, 1.ogg, 2.ogg...

The sound map structure is as follows:
global.snd[| id] = the pointer of the sound*/
tempData = ds_priority_create();
global.snd = ds_list_create();
file = file_find_first(cDirSfx + "*.ogg", 0);
while (file != "")
{
    ds_priority_add(tempData, audio_create_stream(cDirSfx + file), real(string_digits(file)));
    assets++;
    file = file_find_next();
}
file_find_close();
repeat (assets)
{
    ds_list_add(global.snd, ds_priority_find_min(tempData));
    ds_priority_delete_min(tempData);
}
ds_priority_destroy(tempData);
FMODGMS_Sys_Create();
FMODGMS_Sys_Initialize(2);
/*---MUSIC---
The music files are located in data\sfx\bgm and MUST be any audio format supported by FMOD.
Example: 0.ogg, 1.mp3, 2.mod...

"loop.txt" contains music definitions, where every line is formatted like this: track|loop start|loop end

In order to correctly assign loop points to tracks, the sample rate must be 44100 hz.
If a music track doesn't have any loop points, it will only play once.

The music map structure is as follows:
global.mus[| id] = the pointer of the track*/
global.mus = ds_list_create();
file = file_find_first(cDirBgm + "*", 0);
while (file != "")
{
    if (file == "loop.txt") break //Stupid workaround for mistakingly loading loop.txt as a music track
    var slot = string_digits(file), arraySlot = real(slot), track = FMODGMS_Snd_LoadSound(cDirBgm + file);
    var table = file_text_open_read(cDirBgm + "loop.txt"), info;
    while !(file_text_eof(table)) //Look for loop points in the music data table
    {
        info = string_parse(file_text_read_string(table));
        if (info[| 0] == slot) //If the parsed string belongs to this track...
        {
            FMODGMS_Snd_Set_LoopPoints(track, FMODGMS_Util_SecondsToSamples(real(info[| 1]), 44100), FMODGMS_Util_SecondsToSamples(real(info[| 2]), 44100)); //Set loop points for track
            FMODGMS_Snd_Set_LoopMode(track, 1, -1); //Set track to loop
            ds_list_destroy(info);
            break
        }
        ds_list_destroy(info);
        file_text_readln(table);
    }
    ds_list_insert(global.mus, real(slot), track);
    file_text_close(table); //Close the lookup table after
    file = file_find_next();
}
file_find_close();
//Prepare 3D collision system
c_init();
//Level properties
for (i = 0; i &lt; 2; i++)
{
    //Music slot 0 is the main level music. Set it to noone for silence.
    //Music slot 1 is used for battle music. Set it to noone for no battle music in levels.
    global.channel[i] = FMODGMS_Chan_CreateChannel();
    global.levelMusic[i] = noone;
    global.musicVolume[i] = !i;
}
/*global.worldData[0] is a ds_map that contains world data using the following format:
    key = room ID
    value = room data list, where the following positions contain:
            0 = actors list
            1 = texture IDs list
            2 = world models list
            3 = collision shape
            4 = collision object
global.worldData[1] contains the vertex buffer used by sprites in 3D*/
global.worldData[0] = ds_map_create();
global.worldData[1] = vertex_create_buffer();
vertex_begin(global.worldData[1], SMF_format);
smf_add_vertex(global.worldData[1], 0, 1, 0, 0, 0, 1, 0, 1, c_white, 1, c_white, 1);
smf_add_vertex(global.worldData[1], 0, 0, 0, 0, 0, 1, 0, 0, c_white, 1, c_white, 1);
smf_add_vertex(global.worldData[1], 1, 1, 0, 0, 0, 1, 1, 1, c_white, 1, c_white, 1);
smf_add_vertex(global.worldData[1], 0, 0, 0, 0, 0, 1, 0, 0, c_white, 1, c_white, 1);
smf_add_vertex(global.worldData[1], 1, 0, 0, 0, 0, 1, 1, 0, c_white, 1, c_white, 1);
smf_add_vertex(global.worldData[1], 1, 1, 0, 0, 0, 1, 1, 1, c_white, 1, c_white, 1);
vertex_end(global.worldData[1]);
global.fog[0] = 0;
global.fog[1] = 65536;
for (i = 2; i &lt; 5; i++) global.fog[i] = 0;
global.light[0] = -1;
global.light[1] = 0;
global.light[2] = -1;
for (i = 3; i &lt; 6; i++) global.light[i] = 1;
for (i = 6; i &lt; 9; i++) global.light[i] = 0.5;
global.skybox = 0; //The texture ID of the skybox.
global.battle = false; //Used for switching between normal and battle music.
global.dawn = false; //Used to play musDawn on level start. 
global.paused = false;
global.roomName = "Loading"; //Used for Discord Rich Presence
global.roomIcon = 0; //Also for RPC. The number corresponds to which large icon key should be used.
global.minZ = 0; //The minimal Z of the level. Used for deleting actors below this position.
global.deltaTime = 60 / 1000000 * delta_time;
gameLoop = 0;
global.currentRoom = -2; /*PN uses a different room system to get around the memory leak issues with GameMaker: Studio 1.4 involving rooms.
When you change or restart rooms, the game would leak ~3 KB of memory.
As a workaround, only one room must be utilized during the whole session.*/
global.levelRoom = 0; //This is the current room WITHIN the level, unrelated to global.currentRoom.
global.particles = ds_list_create(); /*PN uses a particles list to iterate through each particles (which is a list of data). Should be marginally faster than objects.*/
global.currentNESWall = noone;
pauseBg = -1;
pauseX = -463;
healthY = -46;
setFramerate = true; /*Sets the maximum framerate. The values are as follows:
false - 30
true - 60*/
display_set_gui_size(960, 540);
room_change(0);
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="3" enumb="1">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Level music control &amp; delta timing
global.deltaTime = 60 / 1000000 * delta_time;
//Music control. Sets volume of each track accordingly while the game is unpaused
/*if (global.dawn)
    {if !(audio_is_playing(musDawn))
    {
        music_start();
        global.dawn = false;
    }}
else
    if !(global.paused)
    {
        if (global.levelMusic[global.battle] &amp;&amp; !global.musicVolume[global.battle])
        {
            global.musicVolume[global.battle] = 1;
            audio_sound_gain(global.levelMusic[global.battle], 1, 750);
        }
        if (global.levelMusic[!global.battle] &amp;&amp; global.musicVolume[!global.battle])
        {
            global.musicVolume[!global.battle] = 0;
            audio_sound_gain(global.levelMusic[!global.battle], 0, 750);
        }
    }
if (keyboard_check(vk_numpad0) &amp;&amp; keyboard_check_pressed(vk_numpad1) &amp;&amp; !audio_is_playing(musMosa))
{
    audio_stop_sound(musDawn);
    audio_stop_sound(global.levelMusic[0]);
    audio_stop_sound(global.levelMusic[1]);
    audio_play_sound(musMosa, 1, true);
}*/
//Toggle pause
if (bind_hardcode_pressed(vk_enter, gp_start) &amp;&amp; ((instance_exists(objPlayer) &amp;&amp; !cutscene_exists()) || global.paused) &amp;&amp; !audio_is_playing(global.snd[| cSndPause]))
{
    audio_play_sound(global.snd[| cSndPause], 0, false);
    global.paused = !global.paused;
    FMODGMS_Chan_Set_Volume(global.channel, 1 / (1 + 4 * global.paused));
    if (global.paused)
    {
        pauseBg = background_create_from_surface(application_surface, 0, 0, surface_get_width(application_surface), surface_get_height(application_surface), false, false);
        instance_deactivate_all(true);
        exit
    }
    else
    {
        background_delete(pauseBg);
        instance_activate_all();
    }
}
//Return to title screen
if (bind_hardcode_pressed(vk_escape, gp_select) &amp;&amp; instance_exists(objPlayer))
{
    room_change(-1);
    global.paused = false;
    exit
}
/*The game logic system: This synchronizes the game logic with delta time, allowing you
to play at any framerate. Instead of using step events, all objects use the according
User Defined events as their steps.*/
global.gamepad = gamepad_is_connected(0);
var i = 0, clearInput = true;
repeat (14)
{
    var keyBind = global.bind[i, 0], conBind = global.bind[i, 1];
    if (global.gamepad)
    {
        switch (conBind)
        {
            //Check for analog sticks
            case (gp_axislh):
            case (gp_axisrh): bind_axis(i, false); break
            case (gp_axislv):
            case (gp_axisrv): bind_axis(i, true); break
            default: //Normal buttons
                global.bind[i, 2] = gamepad_button_check(0, conBind);
                global.bind[i, 5] = global.bind[i, 2];
                global.bind[i, 6] = global.bind[i, 2];
        }
        if (gamepad_button_check_pressed(0, conBind)) global.bind[i, 3] = true;
        global.bind[i, 4] = gamepad_button_check_released(0, conBind);
    }
    else
    {
        switch (keyBind)
        {
            //Check if bound to mouse (same for Released)
            case (mb_left):
            case (mb_middle):
            case (mb_right):
                global.bind[i, 2] = mouse_check_button(keyBind);
                if (mouse_check_button_pressed(keyBind)) global.bind[i, 3] = true;
                global.bind[i, 4] = mouse_check_button_released(keyBind);
            break
            default:
                global.bind[i, 2] = keyboard_check(keyBind); //Just key buttons
                if (keyboard_check_pressed(keyBind)) global.bind[i, 3] = true;
                global.bind[i, 4] = keyboard_check_released(keyBind);
        }
        global.bind[i, 5] = global.bind[i, 2];
        global.bind[i, 6] = global.bind[i, 2];
    }
    i++;
}
gameLoop += global.deltaTime;
while (gameLoop)
{
    with (all)
    {
        event_user(14); //Begin Step
        event_user(13); //Step
        event_user(15); //End Step
    }
    //Input clear optimizations are used, since having to reset input values
    //every time global.deltaTime is 1+ is pointless.
    if (clearInput)
    {
        i = 0;
        repeat (14)
        {
            global.bind[i, 3] = false;
            i++;
        }
        clearInput = false;
    }
    gameLoop--;
}
i = 0;
repeat (14)
{
    global.bind[i, 2] = false;
    global.bind[i, 4] = true;
    global.bind[i, 5] = 0;
    global.bind[i, 6] = 0;
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="7" enumb="25">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Update particles
if (global.paused) exit
var i = 0;
repeat (ds_list_size(global.particles) / 12)
{
    global.particles[| i + cParFrame] = global.particles[| i + cParFrame] + global.particles[| i + cParFrameSpd];
    if (global.particles[| i + cParFrame] &gt; image_get_number(sprite_get(global.particles[| i + cParSprite])) - 1)
    {
        repeat (12) ds_list_delete(global.particles, i);
        continue
    }
    global.particles[| i + cParX] = global.particles[| i + cParX] + global.particles[| i + cParHSpeed];
    global.particles[| i + cParY] = global.particles[| i + cParY] + global.particles[| i + cParVSpeed];
    global.particles[| i + cParZ] = global.particles[| i + cParZ] + global.particles[| i + cParZSpeed];
    i += 12;
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="7" enumb="23">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Update GUI elements
pauseX = lerp(pauseX, !global.paused * -463, 0.25);
healthY = lerp(healthY, -46 + 2 * (instance_exists(objPlayer) &amp;&amp; objPlayer.hp &lt; 8) * 46, 0.1)
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="7" enumb="3">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Unload game
FMODGMS_Sys_Close();
discord_free_app();
discord_free_dll();
image_group_destroy("spr");
image_group_destroy("bg");
image_group_destroy("tex");
image_system_cleanup();
directory_destroy("data");
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="8" enumb="64">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Draw pause GUI
if (global.paused) draw_background_ext(pauseBg, 0, 0, display_get_gui_width() / background_get_width(pauseBg), display_get_gui_height() / background_get_height(pauseBg), 0, make_color_rgb(128, 128, 128), 1);
var pX2 = 2 * pauseX + (800 * global.paused);
draw_set_halign(fa_right);
draw_text_transformed(pX2 + 100, 200, "Paused", 2, 2, 0);
draw_set_halign(fa_left);
draw_image(global.bg[| cBgPauseMario], 0, pauseX, 0);
draw_image_ext(sprite_get(cSprIntro), 0, pX2, 100, 0.5, 0.5, 0, c_white, 1);
draw_text(8, 8, string(fps) + "FPS#" + string(fps_real) + " RFPS#" + string(global.deltaTime) + "#" + string(setFramerate));
if (instance_exists(objPlayer)) draw_image_ext(sprite_get(cSprHealth), objPlayer.hp, view_wview[0] * 0.5, healthY, 2, 2, 0, c_white, 1);
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="9" enumb="115">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>var getFull = window_get_fullscreen();
if (getFull) surface_resize(application_surface, 960, 540);
else surface_resize(application_surface, display_get_width(), display_get_height());
window_set_fullscreen(!getFull);
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="9" enumb="114">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>display_reset((display_aa != 4) * 4, false);
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="9" enumb="80">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>var key = ds_map_find_next(global.worldData[0], global.levelRoom);
if (is_undefined(key)) key = ds_map_find_first(global.worldData[0]);
world_room_change(key, false);
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="9" enumb="70">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>setFramerate = !setFramerate;
framerate_set();
</string>
          </argument>
        </arguments>
      </action>
    </event>
  </events>
  <PhysicsObject>0</PhysicsObject>
  <PhysicsObjectSensor>0</PhysicsObjectSensor>
  <PhysicsObjectShape>0</PhysicsObjectShape>
  <PhysicsObjectDensity>0.5</PhysicsObjectDensity>
  <PhysicsObjectRestitution>0.100000001490116</PhysicsObjectRestitution>
  <PhysicsObjectGroup>0</PhysicsObjectGroup>
  <PhysicsObjectLinearDamping>0.100000001490116</PhysicsObjectLinearDamping>
  <PhysicsObjectAngularDamping>0.100000001490116</PhysicsObjectAngularDamping>
  <PhysicsObjectFriction>0.200000002980232</PhysicsObjectFriction>
  <PhysicsObjectAwake>-1</PhysicsObjectAwake>
  <PhysicsObjectKinematic>0</PhysicsObjectKinematic>
  <PhysicsShapePoints/>
</object>
