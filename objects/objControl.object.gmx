<!--This Document is generated by GameMaker, if you edit it by hand then you do so at your own risk!-->
<object>
  <spriteName>&lt;undefined&gt;</spriteName>
  <solid>0</solid>
  <visible>-1</visible>
  <depth>0</depth>
  <persistent>0</persistent>
  <parentName>&lt;undefined&gt;</parentName>
  <maskName>&lt;undefined&gt;</maskName>
  <events>
    <event eventtype="0" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Load game
discord_init_dll();
discord_init_app("732560402873057320");
draw_set_circle_precision(64);
d3d_set_perspective(true);
d3d_set_hidden(true);
d3d_set_culling(true);
draw_set_alpha_test(true);
draw_set_alpha_test_ref_value(0);
audio_falloff_set_model(audio_falloff_exponent_distance);
global.maxRender = 65536;
/*[CONTROL BINDS]
These are used by control to detect inputs. The 2D array indices are as follows:
0 = keyboard bind
1 = gamepad bind
2 = held
3 = pressed
4 = released
5 = axis, positive
6 = axis, negative
(Movement)*/
global.gamepad = false;
global.bind[0, 0] = ord("W"); //Up
global.bind[0, 1] = gp_axislv;
global.bind[1, 0] = ord("A"); //Left
global.bind[1, 1] = gp_axislh;
global.bind[2, 0] = ord("S"); //Down
global.bind[2, 1] = gp_axislv;
global.bind[3, 0] = ord("D"); //Right
global.bind[3, 1] = gp_axislh;
global.bind[4, 0] = vk_space; //Jump
global.bind[4, 1] = gp_face1;
global.bind[5, 0] = ord("X"); //Slidekick
global.bind[5, 1] = gp_face2;
global.bind[6, 0] = ord("E"); //Interact
global.bind[6, 1] = gp_face3;
global.bind[7, 0] = ord("Q"); //Make camera look from player
global.bind[7, 1] = gp_face4;
//(Camera)
global.bind[8, 0] = mb_left; //Free scroll
global.bind[8, 1] = gp_shoulderl;
global.bind[9, 0] = mb_right; //First person
global.bind[9, 1] = gp_shoulderr;
global.bind[10, 1] = gp_axisrv; //Camera up
global.bind[11, 1] = gp_axisrh; //Camera left
global.bind[12, 1] = gp_axisrv; //Camera down
global.bind[13, 1] = gp_axisrh; //Camera right
bind_input_clear();
/*[ASSETS]
All game assets are externalized and stored in a ZIP file. The asset maps are as follows:
global.spr = sprites/models (coming soon)
global.bg = backgrounds
global.tex = textures
global.mtl = materials (coming soon)
global.fnt = fonts (coming soon)
global.snd = sounds
global.mus = music
---
Check if the data folder is in the local appdata. If not, extract data.zip.
If your game gives an error that is related to a missing asset, you have to manually extract data.zip.
Just for the sake of debugging, we disabled data path checking.*/
/*if !(directory_exists("data"))*/ zip_unzip("data.zip", game_save_id);
//Prepare Custom Sprite Framework for loading sprites and backgrounds
image_system_init();
image_group_create("spr");
image_group_create("bg");
image_group_create("tex");
var assets = 0; /*Temporary variable for counting current asset types
---SPRITES---
They are mostly used by the GUI and Actors.
The sprite files are located in data\gfx\spr and MUST be PNGs and numbered.
Example: 0.png, 1.png, 2.png...

"ani.txt" contains sprite definitions, where every line is formatted like this: sprite|frames|rotates|xOffset|yOffset

The sprite list structure is as follows:
global.spr[| id] = a list containing sprite data:
    0 = the sprite itself
    1 = rotates (4-directional)
*/
global.spr = ds_list_create();
image_stream_start("spr", 2048, 2048, 0, true, false);
var file = file_find_first(cDirSpr + "*.png", 0), tempData = ds_list_create();
while (file != "")
{
    var slot = string_digits(file), table = file_text_open_read(cDirSpr + "ani.txt"), frames = 1, rotates = false, xOfs = 0, yOfs = 0, info;
    while !(file_text_eof(table)) //Look for animation data in the animation data table
    {
        info = string_parse(level_read_string(table), "|");
        if (info[| 0] == slot) //If the parsed string belongs to this sprite...
        {
            frames = real(info[| 1]); //Set amount of frames this sprite has
            rotates = real(info[| 2]); //Set "rotatable" flag for sprite
            xOfs = real(info[| 3]); //Set X offset of sprite
            yOfs = real(info[| 4]); //Set Y offset of sprite
            ds_list_destroy(info);
            break
        }
        ds_list_destroy(info);
    }
    //Close the lookup table after and add the sprites to the atlas
    file_text_close(table);
    image_stream_add("spr", slot, cDirSpr + file, frames, xOfs, yOfs);
    ds_list_insert(tempData, real(slot), rotates);
    //Increment the total sprites count and find the next sprite
    assets++;
    file = file_find_next();
}
file_find_close();
image_stream_finish("spr");
for (i = 0; i &lt; assets; i++) //Add every streamed sprite to global.spr
{
    var sprData = ds_list_create();
    ds_list_add(sprData, image_group_find_image("spr", string(i)), tempData[| i]);
    ds_list_add(global.spr, sprData);
}
ds_list_clear(tempData);
assets = 0;
/*---BACKGROUNDS---
They have no frames at all, so we can store way less data than sprites or textures.
The background files are located in data\gfx\bg and MUST be PNGs and numbered.
Example: 0.png, 1.png, 2.png...

The background list structure is as follows:
global.bg[| id] = the pointer of the background graphic*/
global.bg = ds_list_create();
image_stream_start("bg", 1024, 1024, 0, true, false);
file = file_find_first(cDirBg + "*.png", 0);
while (file != "")
{
    var slot = string_digits(file);
    image_stream_add("bg", slot, cDirBg + file, 1, 0, 0);
    //Increment the total backgrounds count and find the next background
    assets++;
    file = file_find_next();
}
file_find_close();
image_stream_finish("bg");
for (i = 0; i &lt; assets; i++) ds_list_add(global.bg, image_group_find_image("bg", string(i)));
assets = 0;
/*---TEXTURES---
Textures are used by levels, which means all the level texture handling is done by PN Editor and no pointer enums are needed.
The texture files are located in data\gfx\tex and MUST be PNGs and numbered.
Example: 0.png, 1.png, 2.png...

"ani.txt" contains texture definitions, where every line is formatted like this: texture|frames|speed

The sprite list structure is as follows:
global.tex[? id] = a list containing texture data:
    0 = pointer of graphic
    1 = animation speed
    2... = the graphic as separate texture pointer(s)*/
global.tex = ds_list_create();
image_stream_start("tex", 1024, 1024, 0, true, false);
file = file_find_first(cDirTex + "*.png", 0);
while (file != "")
{
    var slot = string_digits(file), table = file_text_open_read(cDirTex + "ani.txt"), frames = 1, spd = 1, info;
    while !(file_text_eof(table)) //Look for animation data in the animation data table
    {
        info = string_parse(file_text_read_string(table), "|");
        if (info[| 0] == slot) //If the parsed string belongs to this texture...
        {
            show_debug_message("Found animation data for texture " + slot);
            frames = real(info[| 1]); //Set amount of frames this texture has
            spd = real(info[| 2]); //Animation speed
            ds_list_destroy(info);
            break
        }
        ds_list_destroy(info);
        file_text_readln(table);
    }
    //Close the lookup table after and add the texture to the atlas
    file_text_close(table);
    image_stream_add_3d("tex", slot, cDirTex + file, frames, 0, 0);
    ds_list_insert(tempData, real(slot), spd);
    //Increment the total textures count and find the next background
    assets++;
    file = file_find_next();
}
file_find_close();
image_stream_finish("tex");
for (i = 0; i &lt; assets; i++)
{
    var texData = ds_list_create();
    ds_list_add(texData, image_group_find_image("tex", string(i)), tempData[| i]);
    for (var j = 0, p = texData[| 0], n = image_get_number(p); j &lt; n; j++) ds_list_add(texData, image_get_texture(p, j)); //Add frames to texture data list
    ds_list_add(global.tex, texData);
}
ds_list_destroy(tempData);
assets = 0;
/*---SOUNDS---
The sound files are located in data\sfx\ and MUST be OGGs and numbered.
Example: 0.ogg, 1.ogg, 2.ogg...

The sound map structure is as follows:
global.snd[| id] = the pointer of the sound*/
tempData = ds_priority_create();
global.snd = ds_list_create();
file = file_find_first(cDirSfx + "*.ogg", 0);
while (file != "")
{
    ds_priority_add(tempData, audio_create_stream(cDirSfx + file), real(string_digits(file)));
    assets++;
    file = file_find_next();
}
file_find_close();
repeat (assets)
{
    ds_list_add(global.snd, ds_priority_find_min(tempData));
    ds_priority_delete_min(tempData);
}
ds_priority_destroy(tempData);
FMODGMS_Sys_Create();
FMODGMS_Sys_Initialize(2);
/*---MUSIC---
The music files are located in data\sfx\bgm and MUST be any audio format supported by FMOD.
Example: 0.ogg, 1.mp3, 2.mod...

"loop.txt" contains music definitions, where every line is formatted like this: track|loopStart|loopEnd
In order to correctly assign loop points to tracks, the sample rate must be 44100 hz.
If a music track doesn't have any loop points, it will only play once.

The music map structure is as follows:
global.mus[| id] = the pointer of the track*/
global.mus = ds_list_create();
file = file_find_first(cDirBgm + "*", 0);
while (file != "")
{
    if (file == "loop.txt") break //Stupid workaround for mistakingly loading loop.txt as a music track
    var slot = string_digits(file), arraySlot = real(slot), track = FMODGMS_Snd_LoadSound(cDirBgm + file);
    var table = file_text_open_read(cDirBgm + "loop.txt"), info;
    while !(file_text_eof(table)) //Look for loop points in the music data table
    {
        info = string_parse(file_text_read_string(table), "|");
        if (info[| 0] == slot) //If the parsed string belongs to this track...
        {
            show_debug_message("Found loop points for music " + slot);
            FMODGMS_Snd_Set_LoopPoints(track, FMODGMS_Util_SecondsToSamples(real(info[| 1]), 44100), FMODGMS_Util_SecondsToSamples(real(info[| 2]), 44100)); //Set loop points for track
            FMODGMS_Snd_Set_LoopMode(track, 1, -1); //Set track to loop
            ds_list_destroy(info);
            break
        }
        ds_list_destroy(info);
        file_text_readln(table);
    }
    ds_list_insert(global.mus, real(slot), track);
    file_text_close(table); //Close the lookup table after
    file = file_find_next();
}
file_find_close();
//Prepare 3D collision system
c_init();
worldShape = -1;
worldObject = -1;
global.world = -1;
//Level properties
for (i = 0; i &lt; 2; i++)
{
    //Music slot 0 is the main level music. Set it to noone for silence.
    //Music slot 1 is used for battle music. Set it to noone for no battle music in levels.
    global.channel[i] = FMODGMS_Chan_CreateChannel();
    global.levelMusic[i] = noone;
    global.musicVolume[i] = !i;
    /*global.worldModel has a list of vertex buffers that are rendered by using a fake "vertex batching" method
    to give the illusion of displaying multiple textures on one whole model. Under the hood, it's only
    rendering multiple models as parts of the world, depending on how many textures are used in the map.
    global.worldModel[0] contains world model segments
    global.worldModel[1] contains the texture ID for each segment
    global.worldModel[2] contains the vertex buffer format used for world model segments*/
    global.worldModel[i] = ds_list_create();
}
//Create world
vertex_format_begin();
vertex_format_add_position_3d();
vertex_format_add_textcoord();
global.worldModel[2] = vertex_format_end();
global.skybox = 0; //The texture ID of the skybox.
global.battle = false; //Used for switching between normal and battle music.
global.dawn = false; //Used to play musDawn on level start. 
global.paused = false;
global.roomName = "Loading"; //Used for Discord Rich Presence
global.roomIcon = 0; //Also for RPC. The number corresponds to which large icon key should be used.
global.minZ = 0; //The minimal Z of the level. Used for deleting actors below this position.
global.deltaTime = 60 / 1000000 * delta_time;
global.defaultMatrix = matrix_build(0, 0, 0, 0, 0, 0, 1, 1, 1); //The default matrix. Used for resetting matrices back to default by recycling this variable.
global.currentRoom = -2; /*PN uses a different room system to get around the memory leak issues with GameMaker: Studio 1.4 involving rooms.
When you change or restart rooms, the game would leak ~3 KB of memory.
As a workaround, only one room must be utilized during the whole session.*/
pauseBg = -1;
pauseX = -463;
healthY = -46;
setFramerate = true; /*Sets the maximum framerate. The values are as follows:
false - 30
true - 60*/
display_set_gui_size(960, 540);
room_change(0);
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="3" enumb="1">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Level music control &amp; delta timing
global.deltaTime = 60 / 1000000 * delta_time;
//Music control. Sets volume of each track accordingly while the game is unpaused
/*if (global.dawn)
    {if !(audio_is_playing(musDawn))
    {
        music_start();
        global.dawn = false;
    }}
else
    if !(global.paused)
    {
        if (global.levelMusic[global.battle] &amp;&amp; !global.musicVolume[global.battle])
        {
            global.musicVolume[global.battle] = 1;
            audio_sound_gain(global.levelMusic[global.battle], 1, 750);
        }
        if (global.levelMusic[!global.battle] &amp;&amp; global.musicVolume[!global.battle])
        {
            global.musicVolume[!global.battle] = 0;
            audio_sound_gain(global.levelMusic[!global.battle], 0, 750);
        }
    }
if (keyboard_check(vk_numpad0) &amp;&amp; keyboard_check_pressed(vk_numpad1) &amp;&amp; !audio_is_playing(musMosa))
{
    audio_stop_sound(musDawn);
    audio_stop_sound(global.levelMusic[0]);
    audio_stop_sound(global.levelMusic[1]);
    audio_play_sound(musMosa, 1, true);
}*/
//Toggle pause
if (bind_hardcode_pressed(vk_enter, gp_start) &amp;&amp; ((instance_exists(objPlayer) &amp;&amp; !cutscene_exists()) || global.paused) &amp;&amp; !audio_is_playing(global.snd[| cSndPause]))
{
    audio_play_sound(global.snd[| cSndPause], 0, false);
    global.paused = !global.paused;
    FMODGMS_Chan_Set_Volume(global.channel, 1 / (1 + 4 * global.paused));
    if (global.paused)
    {
        pauseBg = background_create_from_surface(application_surface, 0, 0, surface_get_width(application_surface), surface_get_height(application_surface), false, false);
        instance_deactivate_all(true);
        exit
    }
    else
    {
        background_delete(pauseBg);
        instance_activate_all();
    }
}
//Return to title screen
if (bind_hardcode_pressed(vk_escape, gp_select) &amp;&amp; instance_exists(objPlayer))
{
    room_change(-1);
    global.paused = false;
    exit
}
/*The game logic system: This synchronizes the game logic with delta time, allowing you
to play at any framerate. Instead of using step events, all objects use the according
User Defined events as their steps.*/
global.gamepad = gamepad_is_connected(0);
var i, clearInput = false;
for (i = 0; i &lt; 14; i++)
{
    var keyBind = global.bind[i, 0], conBind = global.bind[i, 1];
    if (global.gamepad)
    {
        switch (conBind)
        {
            //Check for analog sticks
            case (gp_axislh):
            case (gp_axisrh): bind_axis(i, false); break
            case (gp_axislv):
            case (gp_axisrv): bind_axis(i, true); break
            default: //Normal buttons
                global.bind[i, 2] = gamepad_button_check(0, conBind);
                global.bind[i, 5] = global.bind[i, 2];
                global.bind[i, 6] = global.bind[i, 2];
        }
        global.bind[i, 4] = gamepad_button_check_released(0, conBind);
    }
    else
    {
        switch (keyBind)
        {
            //Check if bound to mouse (same for Released)
            case (mb_left):
            case (mb_middle):
            case (mb_right):
                global.bind[i, 2] = mouse_check_button(keyBind);
                global.bind[i, 4] = mouse_check_button_released(keyBind);
            break
            default:
                global.bind[i, 2] = keyboard_check(keyBind); //Just key buttons
                global.bind[i, 4] = keyboard_check_released(keyBind);
        }
        global.bind[i, 5] = global.bind[i, 2];
        global.bind[i, 6] = global.bind[i, 2];
    }
    global.bind[i, 3] = bind_hardcode_pressed(keyBind, conBind);
}
var gameLoop = global.deltaTime;
while (gameLoop--)
{
    with (all)
    {
        event_user(14); //Begin Step
        event_user(13); //Step
        event_user(15); //End Step
    }
    //Input clear optimizations are used, since having to reset input values
    //every time global.deltaTime is 1+ is pointless.
    if !(clearInput)
    {
        bind_input_clear();
        clearInput = true;
    }
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="7" enumb="23">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Update GUI elements
pauseX = lerp(pauseX, !global.paused * -463, 0.25);
healthY = lerp(healthY, -46 + 2 * (instance_exists(objPlayer) &amp;&amp; objPlayer.hp &lt; 8) * 46, 0.1)
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="7" enumb="3">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Unload game
FMODGMS_Sys_Close();
discord_free_app();
discord_free_dll();
image_group_destroy("spr");
image_group_destroy("bg");
image_group_destroy("tex");
image_system_cleanup();
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="8" enumb="64">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Draw pause GUI
if (global.paused) draw_background_ext(pauseBg, 0, 0, display_get_gui_width() / background_get_width(pauseBg), display_get_gui_height() / background_get_height(pauseBg), 0, make_color_rgb(128, 128, 128), 1);
var pX2 = 2 * pauseX + (800 * global.paused);
draw_set_halign(fa_right);
draw_text_transformed(pX2 + 100, 200, "Paused", 2, 2, 0);
draw_set_halign(fa_left);
draw_image(global.bg[| cBgPauseMario], 0, pauseX, 0);
draw_image_ext(sprite_get(cSprIntro), 0, pX2, 100, 0.5, 0.5, 0, c_white, 1);
draw_text(8, 8, string(round(fps_real)) + " FPS#" + string(global.deltaTime) + "#" + string(setFramerate));
if (instance_exists(objPlayer)) draw_image_ext(sprite_get(cSprHealth), objPlayer.hp, view_wview[0] * 0.5, healthY, 2, 2, 0, c_white, 1);
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="9" enumb="115">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>var getFull = window_get_fullscreen();
if (getFull) surface_resize(application_surface, 960, 540);
else surface_resize(application_surface, display_get_width(), display_get_height());
window_set_fullscreen(!getFull);
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="9" enumb="114">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>display_reset((display_aa != 4) * 4, false);
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="9" enumb="70">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>setFramerate = !setFramerate;
framerate_set();
</string>
          </argument>
        </arguments>
      </action>
    </event>
  </events>
  <PhysicsObject>0</PhysicsObject>
  <PhysicsObjectSensor>0</PhysicsObjectSensor>
  <PhysicsObjectShape>0</PhysicsObjectShape>
  <PhysicsObjectDensity>0.5</PhysicsObjectDensity>
  <PhysicsObjectRestitution>0.100000001490116</PhysicsObjectRestitution>
  <PhysicsObjectGroup>0</PhysicsObjectGroup>
  <PhysicsObjectLinearDamping>0.100000001490116</PhysicsObjectLinearDamping>
  <PhysicsObjectAngularDamping>0.100000001490116</PhysicsObjectAngularDamping>
  <PhysicsObjectFriction>0.200000002980232</PhysicsObjectFriction>
  <PhysicsObjectAwake>-1</PhysicsObjectAwake>
  <PhysicsObjectKinematic>0</PhysicsObjectKinematic>
  <PhysicsShapePoints/>
</object>
